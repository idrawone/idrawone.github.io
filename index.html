<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('https://idrawone.github.io').hostname,
    root: '/',
    scheme: 'Gemini',
    version: '7.7.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: true,
    lazyload: false,
    pangu: false,
    comments: {"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}
  };
</script>

  <meta name="description" content="knowledge is power">
<meta property="og:type" content="website">
<meta property="og:title" content="David&#39;s Blog">
<meta property="og:url" content="https://idrawone.github.io/index.html">
<meta property="og:site_name" content="David&#39;s Blog">
<meta property="og:description" content="knowledge is power">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="David Zhang">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://idrawone.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false
  };
</script>

  <title>David's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="David's Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">David's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">knowledge is power</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>About</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>Archives<span class="badge">27</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2022/10/14/global-index-a-different-approach/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/14/global-index-a-different-approach/" class="post-title-link" itemprop="url">Global Index, a different approach</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-10-14 01:00:00 / Modified: 14:12:30" itemprop="dateCreated datePublished" datetime="2022-10-14T01:00:00-07:00">2022-10-14</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/global/" itemprop="url" rel="index">
                    <span itemprop="name">global</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/global/index/" itemprop="url" rel="index">
                    <span itemprop="name">index</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/global/index/partition/" itemprop="url" rel="index">
                    <span itemprop="name">partition</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/global/index/partition/unique/" itemprop="url" rel="index">
                    <span itemprop="name">unique</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/global/index/partition/unique/performance/" itemprop="url" rel="index">
                    <span itemprop="name">performance</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-postgres-on-lustre.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>A few years ago, there was a <a href="https://www.postgresql.org/message-id/CALtqXTcurqy1PKXzP9XO%3DofLLA5wBSo77BnUnYVEZpmcA3V0ag%40mail.gmail.com" target="_blank" rel="noopener">proposal</a> about adding the global index support to PostgreSQL for partitioned table. Following that proposal, there were many discussions and also an initial version <a href="https://www.postgresql.org/message-id/78E4E097-EEFE-4755-AAE4-97B60AD53B5B%40alibaba-inc.com" target="_blank" rel="noopener">POC</a> to demonstrate the possibility, the technical challenges and the potential benefits, etc. However, the global index feature is still not available in PostgreSQL official release yet. This blog is trying to share a different approach and hopefully it is can to be implemented to benefit some users.</p>
<h4 id="2-Basic-global-index-requirement"><a href="#2-Basic-global-index-requirement" class="headerlink" title="2. Basic global index requirement"></a>2. Basic global index requirement</h4><p>There are many reasons to have this global index to be available on Postgres partitioned table, such as the performance enhancement for read-only queries across multiple partitions, the uniqueness of using non-partition key as index across multiple partitions, etc. For example, if users find out a table grow too fast and they have to split this table into partitions based on key1 while the applications are using key2 to retrieve data. In this case, with the global index available, they potentially can avoid the unnecessary changes to the applications. </p>
<h4 id="3-Different-approaches"><a href="#3-Different-approaches" class="headerlink" title="3. Different approaches"></a>3. Different approaches</h4><p>To address this <code>global</code> index requirement, one POC in PostgreSQL community discussion was trying to store the global index in a single index relation. In this way, it definitely will have better performance as all the index tuples are stored in one index relation. However, one issue is that it will encounter the physical size limitation on one relation file. Another issue is that each detach needs to clean up this single global index relation and it is kind of violating one of the original partitioned table design ideas. As it was mentioned that one of the partitioned table design ideas is <code>to cheaply add and remove partitions</code>.</p>
<p>Another approach is that we can consider to keep the <code>global</code> index relation stored separately based on partition key and add the logic to allow globally access the separated <code>global</code> index relation with uniqueness restriction on a non-partitioned key. In this approach, we keep the benefits of the original partitioned table design. One is the size limitation of one relation as we have <code>global</code> index relation stored separately, the other one is that it is easy to maintain the detach performance. For attaching partition, it will depend on whether it is an empty table or table with data or even index.</p>
<p>The main idea of this approach is to use the existing feature by removing the restriction of must having partition key involved, and adds logic to handle the global uniqueness check on non-partition key and crossing partitions sort during index build.</p>
<h4 id="4-Some-initial-tests"><a href="#4-Some-initial-tests" class="headerlink" title="4. Some initial tests"></a>4. Some initial tests</h4><p>Based on the second approach with some basic changes, here are some simple test results to share.</p>
<h5 id="4-1-Setup-partitions"><a href="#4-1-Setup-partitions" class="headerlink" title="4.1. Setup partitions"></a>4.1. Setup partitions</h5><p>First, using pgbench to create 12 partitions and load data with scale 1000. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pgbench -i -s 1000 --partitions&#x3D;12 --partition-method&#x3D;range -d postgres</span><br></pre></td></tr></table></figure>

<h5 id="4-2-Setup-global-index"><a href="#4-2-Setup-global-index" class="headerlink" title="4.2. Setup global index"></a>4.2. Setup <code>global</code> index</h5><p>Second, create the <code>global</code> index without partition key (aid) restriction, but with global uniqueness check on non-partition key (bid). </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# create unique index gidx on pgbench_accounts using btree(bid) global;</span><br></pre></td></tr></table></figure>

<p>Here is how the schema looks like after a <code>global</code> index has been created.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# \d+ pgbench_accounts</span><br><span class="line">                                   Partitioned table &quot;public.pgbench_accounts&quot;</span><br><span class="line">  Column  |     Type      | Collation | Nullable | Default | Storage  | Compression | Stats target | Description </span><br><span class="line">----------+---------------+-----------+----------+---------+----------+-------------+--------------+-------------</span><br><span class="line"> aid      | integer       |           | not null |         | plain    |             |              | </span><br><span class="line"> bid      | integer       |           |          |         | plain    |             |              | </span><br><span class="line"> abalance | integer       |           |          |         | plain    |             |              | </span><br><span class="line"> filler   | character(84) |           |          |         | extended |             |              | </span><br><span class="line">Partition key: RANGE (aid)</span><br><span class="line">Indexes:</span><br><span class="line">    &quot;pgbench_accounts_pkey&quot; PRIMARY KEY, btree (aid)</span><br><span class="line">    &quot;gidx&quot; UNIQUE, btree (bid)</span><br><span class="line">Partitions: pgbench_accounts_1 FOR VALUES FROM (MINVALUE) TO (8333335),</span><br><span class="line">            pgbench_accounts_10 FOR VALUES FROM (75000007) TO (83333341),</span><br><span class="line">            pgbench_accounts_11 FOR VALUES FROM (83333341) TO (91666675),</span><br><span class="line">            pgbench_accounts_12 FOR VALUES FROM (91666675) TO (MAXVALUE),</span><br><span class="line">            pgbench_accounts_2 FOR VALUES FROM (8333335) TO (16666669),</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>To distinguish the <code>global</code> index relation from normal index relation, here we use <code>g</code> to replace <code>i</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# select oid, relname, relnamespace, reltype, reloftype, relam, relfilenode, relpages, reltuples, relhasindex, relkind from pg_class where relnamespace&#x3D;2200 order by oid;</span><br><span class="line">  oid  |           relname           | relnamespace | reltype | reloftype | relam | relfilenode | relpages | reltuples | relhasindex | relkind </span><br><span class="line">-------+-----------------------------+--------------+---------+-----------+-------+-------------+----------+-----------+-------------+---------</span><br><span class="line"> 16690 | gidx                        |         2200 |       0 |         0 |   403 |           0 |        0 |              0 | f           | I</span><br><span class="line"> 16691 | pgbench_accounts_1_bid_idx  |         2200 |       0 |         0 |   403 |       16691 |    22852 |   8.333334e+06 | f           | g</span><br><span class="line"> 16692 | pgbench_accounts_2_bid_idx  |         2200 |       0 |         0 |   403 |       16692 |    22852 |   8.333334e+06 | f           | g</span><br><span class="line"> 16693 | pgbench_accounts_3_bid_idx  |         2200 |       0 |         0 |   403 |       16693 |    22852 |   8.333334e+06 | f           | g</span><br><span class="line">...</span><br></pre></td></tr></table></figure>


<h5 id="4-3-Query-with-global-index"><a href="#4-3-Query-with-global-index" class="headerlink" title="4.3. Query with global index"></a>4.3. Query with <code>global</code> index</h5><p>Now, let’s run a simple query using non-partition key (bid) to compare the performance</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# select * from pgbench_accounts where bid&#x3D;75000007;</span><br><span class="line">   aid    |   bid    | abalance |                                        filler                                        </span><br><span class="line">----------+----------+----------+--------------------------------------------------------------------------------------</span><br><span class="line"> 75000007 | 75000007 |        0 |                                                                                     </span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 2.243 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">postgres&#x3D;# explain select * from pgbench_accounts where bid&#x3D;75000007;</span><br><span class="line">                                                  QUERY PLAN                                                  </span><br><span class="line">--------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Append  (cost&#x3D;0.43..101.46 rows&#x3D;12 width&#x3D;97)</span><br><span class="line">   -&gt;  Index Scan using pgbench_accounts_1_bid_idx on pgbench_accounts_1  (cost&#x3D;0.43..8.45 rows&#x3D;1 width&#x3D;97)</span><br><span class="line">         Index Cond: (bid &#x3D; 75000007)</span><br><span class="line">   -&gt;  Index Scan using pgbench_accounts_2_bid_idx on pgbench_accounts_2  (cost&#x3D;0.43..8.45 rows&#x3D;1 width&#x3D;97)</span><br><span class="line">         Index Cond: (bid &#x3D; 75000007)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>As the explain shows above, the index scan has been used.</p>
<h5 id="4-4-Query-without-index"><a href="#4-4-Query-without-index" class="headerlink" title="4.4. Query without index"></a>4.4. Query without index</h5><p>Then, let’s drop the global index, and run the same query again,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# drop index gidx;</span><br><span class="line">DROP INDEX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select * from pgbench_accounts where bid&#x3D;75000007;</span><br><span class="line">   aid    |   bid    | abalance |                                        filler                                        </span><br><span class="line">----------+----------+----------+--------------------------------------------------------------------------------------</span><br><span class="line"> 75000007 | 75000007 |        0 |                                                                                     </span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 8345.590 ms (00:08.346)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">postgres&#x3D;# explain select * from pgbench_accounts where bid&#x3D;75000007;</span><br><span class="line">                                          QUERY PLAN                                          </span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line"> Gather  (cost&#x3D;1000.00..2161189.59 rows&#x3D;12 width&#x3D;97)</span><br><span class="line">   Workers Planned: 2</span><br><span class="line">   -&gt;  Parallel Append  (cost&#x3D;0.00..2160188.39 rows&#x3D;12 width&#x3D;97)</span><br><span class="line">         -&gt;  Parallel Seq Scan on pgbench_accounts_1  (cost&#x3D;0.00..180015.78 rows&#x3D;1 width&#x3D;97)</span><br><span class="line">               Filter: (bid &#x3D; 75000007)</span><br><span class="line">         -&gt;  Parallel Seq Scan on pgbench_accounts_2  (cost&#x3D;0.00..180015.78 rows&#x3D;1 width&#x3D;97)</span><br><span class="line">               Filter: (bid &#x3D; 75000007)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Here, we can see a big performance difference between with and without global index (2.243 ms vs. 8345.590 ms)</p>
<h5 id="4-5-Query-with-index-having-partition-key-restriction"><a href="#4-5-Query-with-index-having-partition-key-restriction" class="headerlink" title="4.5. Query with index having partition-key restriction"></a>4.5. Query with index having partition-key restriction</h5><p>Now, let’s build an index with partition key (aid),</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# create unique index lidx on pgbench_accounts using btree(aid, bid);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">postgres&#x3D;# create unique index lidx on pgbench_accounts using btree(aid, bid);</span><br><span class="line">CREATE INDEX</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select * from pgbench_accounts where bid&#x3D;75000007;</span><br><span class="line">   aid    |   bid    | abalance |                                        filler                                        </span><br><span class="line">----------+----------+----------+--------------------------------------------------------------------------------------</span><br><span class="line"> 75000007 | 75000007 |        0 |                                                                                     </span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">Time: 3312.177 ms (00:03.312)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# explain select * from pgbench_accounts where bid&#x3D;75000007;</span><br><span class="line">                                                      QUERY PLAN                                                       </span><br><span class="line">-----------------------------------------------------------------------------------------------------------------------</span><br><span class="line"> Append  (cost&#x3D;0.43..1846949.37 rows&#x3D;12 width&#x3D;97)</span><br><span class="line">   -&gt;  Index Scan using pgbench_accounts_1_aid_bid_idx on pgbench_accounts_1  (cost&#x3D;0.43..153912.45 rows&#x3D;1 width&#x3D;97)</span><br><span class="line">         Index Cond: (bid &#x3D; 75000007)</span><br><span class="line">   -&gt;  Index Scan using pgbench_accounts_2_aid_bid_idx on pgbench_accounts_2  (cost&#x3D;0.43..153912.45 rows&#x3D;1 width&#x3D;97)</span><br><span class="line">         Index Cond: (bid &#x3D; 75000007)</span><br></pre></td></tr></table></figure>
<p>With the same query, we still can see a big difference between <code>global</code> index and original index with partition key restriction (2.243 ms vs. 3312.177 ms).</p>
<h5 id="4-6-Uniqueness-on-non-partition-key"><a href="#4-6-Uniqueness-on-non-partition-key" class="headerlink" title="4.6. Uniqueness on non-partition key"></a>4.6. Uniqueness on non-partition key</h5><p>Below examples are trying to demonstrate that without the uniqueness check on non-partition key offered by <code>global</code> index, a duplicated bid record insertion can’t not be blocked. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# insert into pgbench_accounts values(100000001, 75000007, 0, &#39;&#39;);</span><br><span class="line">INSERT 0 1</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# select * from pgbench_accounts where bid&#x3D;75000007;</span><br><span class="line">    aid    |   bid    | abalance |                                        filler                                        </span><br><span class="line">-----------+----------+----------+--------------------------------------------------------------------------------------</span><br><span class="line">  75000007 | 75000007 |        0 |                                                                                     </span><br><span class="line"> 100000001 | 75000007 |        0 |                                                                                     </span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure>

<p>However, with the uniqueness check on non-partition key offered by <code>global</code> index, the insertion of a duplicated bid record can be detected and blocked out.<br>postgres=# insert into pgbench_accounts values(100000001, 75000007, 0, ‘’);<br>ERROR:  duplicate key value violates unique constraint “pgbench_accounts_10_bid_idx”<br>DETAIL:  Key (bid)=(75000007) already exists.</p>
<h4 id="5-Summary"><a href="#5-Summary" class="headerlink" title="5. Summary"></a>5. Summary</h4><p>In this blog, I explained a different approach to achieve logical <code>global</code> index features but keep the physical storage separately, which can potential keep the original partitioned table design idea on PostgreSQL, and demonstrated the benefit of query performance and the uniqueness check on non-partition key.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2022/07/22/how-to-setup-lustre-file-system-and-run-postgres-on-it/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/07/22/how-to-setup-lustre-file-system-and-run-postgres-on-it/" class="post-title-link" itemprop="url">How to setup Lustre file system and run Postgres on it</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-07-22 01:00:00 / Modified: 13:31:56" itemprop="dateCreated datePublished" datetime="2022-07-22T01:00:00-07:00">2022-07-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/parallel/" itemprop="url" rel="index">
                    <span itemprop="name">parallel</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/parallel/distributed/" itemprop="url" rel="index">
                    <span itemprop="name">distributed</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/parallel/distributed/file/" itemprop="url" rel="index">
                    <span itemprop="name">file</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/parallel/distributed/file/system/" itemprop="url" rel="index">
                    <span itemprop="name">system</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/parallel/distributed/file/system/storage/" itemprop="url" rel="index">
                    <span itemprop="name">storage</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-postgres-on-lustre.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>Similar to PostgreSQL, Lustre file system is also an open source project which started about 20 years ago. According to <a href="https://en.wikipedia.org/wiki/Lustre_(file_system)" target="_blank" rel="noopener">Wikipedia</a>, Lustre file system is a type of parallel distributed file system, and is designed for large-scale cluster computing with native Remote Direct Memory Access (RDMA) support. Lustre file systems are scalable and can be part of multiple computer clusters with tens of thousands of client nodes, tens of petabytes (PB) of storage on hundreds of servers, and more than a terabyte per second (TB/s) of aggregate I/O throughput. This blog will explain how to setup a simple Lustre file system on CentOS 7 and run PostgreSQL on it.</p>
<h4 id="2-Lustre-file-system"><a href="#2-Lustre-file-system" class="headerlink" title="2. Lustre file system"></a>2. Lustre file system</h4><p>To deliver parallel file access and improve I/O performance, Lustre file system separates out metadata services and data services. From high level architecture point of view, Lustre file system contains below basic components:<br>Management Server (MGS), provides configuration information about how the file system is configured, notifies clients about changes in the file system configuration and plays a role in the Lustre recovery process.<br>Metadata Server (MDS),  manages the file system namespace and provides metadata services to clients such as filename lookup, directory information, file layouts, and access permissions.<br>Metadata Target (MDT), stores metadata information, and holds the root information of the file system.<br>Object Storage Server (OSS), stores file data objects and makes the file contents available to Lustre clients.<br>Object Storage Target (OST), stores the contents of user files.<br>Lustre Client, mounts the Lustre file system and makes the contents of the namespace visible to the users.<br>Lustre Networking (LNet) - a network protocol used for communication between Lustre clients and servers with native RDMA supported.<br>If you want to know more details inside Lustre, you can refer to <a href="https://wiki.lustre.org/Understanding_Lustre_Internals" target="_blank" rel="noopener">Understanding Lustre Internals</a>.</p>
<h4 id="3-Setup-Lustre-on-CentOS-7"><a href="#3-Setup-Lustre-on-CentOS-7" class="headerlink" title="3. Setup Lustre on CentOS 7"></a>3. Setup Lustre on CentOS 7</h4><p>To setup a simple Lustre file system for PostgreSQL, we need to have 4 machines: MGS-MDS-MDT server, OSS-OST server, Lustre client1 and client2 (Postgres Servers). In this blog, I used three CentOS 7 virtual machines with below network settings:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MGS-MDS-MDT: 10.10.1.1</span><br><span class="line">OSS-OST: 10.10.1.2</span><br><span class="line">Client1&#x2F;PG Server: 10.10.1.10</span><br><span class="line">Client2&#x2F;PG Server: 10.10.1.20</span><br></pre></td></tr></table></figure>


<h5 id="3-1-Install-Lustre"><a href="#3-1-Install-Lustre" class="headerlink" title="3.1. Install Lustre"></a>3.1. Install Lustre</h5><p>To avoid dealing with Firewall and SELinux policy issues, I simply disabled them like below,<br>Set <code>SELINUX=disabled</code> in /etc/selinux/config, and run commands,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<p>Add Lustre release information to <code>/etc/yum.repos.d/lustre.repo</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[lustre-server]</span><br><span class="line">name&#x3D;CentOS-$releasever - Lustre</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;build.whamcloud.com&#x2F;job&#x2F;lustre-master&#x2F;arch&#x3D;x86_64%2Cbuild_type&#x3D;server%2Cdistro&#x3D;el7%2Cib_stack&#x3D;inkernel&#x2F;lastStableBuild&#x2F;artifact&#x2F;artifacts&#x2F;</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;downloads.whamcloud.com&#x2F;public&#x2F;lustre&#x2F;latest-release&#x2F;el7&#x2F;server&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line"></span><br><span class="line">[e2fsprogs]</span><br><span class="line">name&#x3D;CentOS-$releasever - Ldiskfs</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;build.whamcloud.com&#x2F;job&#x2F;e2fsprogs-master&#x2F;arch&#x3D;x86_64%2Cdistro&#x3D;el7&#x2F;lastStableBuild&#x2F;artifact&#x2F;_topdir&#x2F;RPMS&#x2F;</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;downloads.whamcloud.com&#x2F;public&#x2F;e2fsprogs&#x2F;latest&#x2F;el7&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br><span class="line"></span><br><span class="line">[lustre-client]</span><br><span class="line">name&#x3D;CentOS-$releasever - Lustre</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;build.whamcloud.com&#x2F;job&#x2F;lustre-master&#x2F;arch&#x3D;x86_64%2Cbuild_type&#x3D;client%2Cdistro&#x3D;el7%2Cib_stack&#x3D;inkernel&#x2F;lastStableBuild&#x2F;artifact&#x2F;artifacts&#x2F;</span><br><span class="line">baseurl&#x3D;https:&#x2F;&#x2F;downloads.whamcloud.com&#x2F;public&#x2F;lustre&#x2F;latest-release&#x2F;el7.9.2009&#x2F;client&#x2F;</span><br><span class="line">gpgcheck&#x3D;0</span><br></pre></td></tr></table></figure>
<p>Then update yum and install the filesystem utilities <code>e2fsprogs</code> to deal with ext4</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum update &amp;&amp; yum upgrade -y e2fsprogs</span><br></pre></td></tr></table></figure>
<p>If there is no errors, then install Lustre server and tools with <code>yum install -y lustre-tests</code></p>
<h5 id="3-2-Setup-lnet-network"><a href="#3-2-Setup-lnet-network" class="headerlink" title="3.2. Setup lnet network"></a>3.2. Setup lnet network</h5><p>Depends on your network interfaces setup, add the lnet configuration correspondingly. For example, all my 3 CentOS 7 has a network interface <code>enp0s8</code>, therefore, I added the configuration <code>options lnet networks=&quot;tcp0(enp0s8)&quot;</code> to <code>/etc/modprobe.d/lnet.conf</code> as my Lustre lnet network configuration.</p>
<p>Then we need to load the lnet driver to the kernel, and start the lnet network by running below commands,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">modprobe lustre</span><br><span class="line">lsmod | grep lustre</span><br><span class="line">modprobe lnet</span><br><span class="line">lsmod | grep lnet</span><br><span class="line">lctl network up</span><br></pre></td></tr></table></figure>

<p>You can check if the lnet network is running on your Ethernet interface using command <code>lctl list_nids</code>, and you should see something like below,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10.10.1.1@tcp</span><br></pre></td></tr></table></figure>
<p>You can try to ping other Lustre servers over the lnet network by running command <code>lctl ping 10.10.1.2@tcp1</code>. If the lnet network is working, then you should see below output,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12345-0@lo</span><br><span class="line">12345-10.10.1.2@tcp</span><br></pre></td></tr></table></figure>


<h5 id="3-3-Setup-MGS-MDS-MDT-and-OSS-OST-servers"><a href="#3-3-Setup-MGS-MDS-MDT-and-OSS-OST-servers" class="headerlink" title="3.3. Setup MGS/MDS/MDT and OSS/OST servers"></a>3.3. Setup MGS/MDS/MDT and OSS/OST servers</h5><p>To set up the storage for MGS/MDS/MDT server, I added one dedicated virtual disk (/dev/sdb), created one partition (/dev/sdb1) and formatted it to ext4. </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk &#x2F;dev&#x2F;sdb</span><br><span class="line">...</span><br><span class="line">mkfs -t ext4 &#x2F;dev&#x2F;sdb1</span><br></pre></td></tr></table></figure>
<p>You need to repeat the same process on OSS/OST server to add actual files storage disk.</p>
<p>If everything goes fine, then it is time to mount the disk on Lustre servers. First, we need to mount the disk on MGS/MDS/MDT server by running below command,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.lustre --reformat --fsname&#x3D;lustrefs --mgs --mdt --index&#x3D;0 &#x2F;dev&#x2F;sdb1</span><br><span class="line">mkdir &#x2F;mgsmdt_mount</span><br><span class="line">mount -t lustre &#x2F;dev&#x2F;sdb1 &#x2F;mgsmdt_mount</span><br></pre></td></tr></table></figure>

<p>Second, we mount the disk on OSS/OST server using below commands,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkfs.lustre --reformat --ost --fsname&#x3D;lustrefs --mgsnode&#x3D;10.10.1.1@tcp1 --index&#x3D;0 &#x2F;dev&#x2F;sdb1</span><br><span class="line">mkdir &#x2F;ostoss_mount </span><br><span class="line">mount -t lustre &#x2F;dev&#x2F;sdb1 &#x2F;ostoss_mount</span><br></pre></td></tr></table></figure>


<h5 id="3-4-Setup-Lustre-clients"><a href="#3-4-Setup-Lustre-clients" class="headerlink" title="3.4. Setup Lustre clients"></a>3.4. Setup Lustre clients</h5><p>After the Luster server’s setup is done, we can simply mount the lustre file system on client by running below commands, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;mnt&#x2F;lustre</span><br><span class="line">mount -t lustre 10.10.1.1@tcp0:&#x2F;lustrefs &#x2F;mnt&#x2F;lustre</span><br></pre></td></tr></table></figure>
<p>If no error, then you can verify it by creating a text file and entering some information from one client, and check it from another client.</p>
<h5 id="3-5-Setup-Postgres-on-Lustre-file-system"><a href="#3-5-Setup-Postgres-on-Lustre-file-system" class="headerlink" title="3.5. Setup Postgres on Lustre file system"></a>3.5. Setup Postgres on Lustre file system</h5><p>As there are some many tutorials about how to setup Postgres on CentOS, I will skip this part. Assume you have installed Postgres either from an “official release” or compiled from the source code yourself, then run below tests from client1,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">initdb -D &#x2F;mnt&#x2F;lustre&#x2F;pgdata</span><br><span class="line">pg_ctl -D &#x2F;mnt&#x2F;lustre&#x2F;pgdata -l &#x2F;tmp&#x2F;logfile start</span><br><span class="line">create table test(a int, b text);</span><br><span class="line">insert into test values(generate_series(1, 1000), &#39;helloworld&#39;);</span><br><span class="line">select count(*) from test;</span><br><span class="line">pg_ctl -D &#x2F;mnt&#x2F;lustre&#x2F;pgdata -l &#x2F;tmp&#x2F;logfile stop</span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line"></span><br><span class="line">Then run below commands from client2,</span><br></pre></td></tr></table></figure>
<p>pg_ctl -D /mnt/lustre/pgdata -l /tmp/logfile start<br>select count(*) from test;<br>pg_ctl -D /mnt/lustre/pgdata -l /tmp/logfile stop</p>
<pre><code>From the above simple tests, you can confirm that the table created and records inserted by client1 are stored on remote Lustre file system, and if Postgres server stop on client1, then you can start Postgres server on client2 and query all the records inserted by client1. 


#### 4. Summary
In this blog, I explained how to set up a parallel distributed file system - Lustre on a local environment, and verify it with PostgreSQL servers. I hope this blog can help you if you want to evaluate some distributed file systems.</code></pre>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2022/06/24/one-idea-of-accessing-primarys-buffer-blocks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/24/one-idea-of-accessing-primarys-buffer-blocks/" class="post-title-link" itemprop="url">One idea of accessing Primary's buffer blocks</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-06-24 01:00:00 / Modified: 12:49:35" itemprop="dateCreated datePublished" datetime="2022-06-24T01:00:00-07:00">2022-06-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/primary/" itemprop="url" rel="index">
                    <span itemprop="name">primary</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/primary/buffer/" itemprop="url" rel="index">
                    <span itemprop="name">buffer</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/primary/buffer/block/" itemprop="url" rel="index">
                    <span itemprop="name">block</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/primary/buffer/block/share/" itemprop="url" rel="index">
                    <span itemprop="name">share</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/primary/buffer/block/share/storage/" itemprop="url" rel="index">
                    <span itemprop="name">storage</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-remote-access-buffer-blocks.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>PostgreSQL is a great open source project for many reasons. One of the reasons I like it is because of the design of buffer blocks addressing. In this blog, I am going to explain a possible way to share a Primary’s buffer blocks with a Standby. If you want to know more about how buffer tag works, you can refer to my <a href="https://www.highgo.ca/2021/07/23/the-amazing-buffer-tag-in-postgresql/" target="_blank" rel="noopener">previous blog</a>.</p>
<h4 id="2-Primary-and-Standby"><a href="#2-Primary-and-Standby" class="headerlink" title="2. Primary and Standby"></a>2. Primary and Standby</h4><p>In Postgres, a Primary is an active database which accepts connections and performs read-write SQL operations; a Standby is a copy of the active database, and it also accepts connection but only for read-only SQL operations. Because the Standby needs to perform the ‘copy’ action in order to synchronize with Primary database, technically they are not exactly <code>equal</code> if a SQL query is time sensitive. Then, the question is can we let a Standby to be <code>equal</code> to a Primary? </p>
<p>The answer is <code>probably!</code>. I recently did some experimental tests to see if a Standby can access Primary’s buffer blocks in order to check the data which has not been replicated yet. The results is very positive.</p>
<h4 id="3-How-to-share-it"><a href="#3-How-to-share-it" class="headerlink" title="3. How to share it"></a>3. How to share it</h4><p>To achieve this experimental remote buffer blocks access, here are a few things I did:<br>On Primary side,</p>
<ol>
<li>start a simple dedicated TCP/IP server to listen for the buffer tag request from Standby</li>
<li>check if the buffer block in memory for received buffer tag</li>
<li>If found and dirty then sends the 8KB buffer block to Standby</li>
<li>If not found then simply answer not found</li>
</ol>
<p>On Standby side,</p>
<ol>
<li>add a simple TCP/IP client for buffer manager</li>
<li>send buffer tag request to Primary when buffer manager needs to load a data block from disk</li>
<li>add 8KB data block to shared buffer if received from Primary</li>
<li>load data block from disk if buffer block not found on Primary </li>
<li>skip buffer tag check to avoid use cashed data blocks</li>
</ol>
<p>With these basic changes, a Standby can access Primary’s buffer blocks and get the same query results even the data has not been replicated yet (in my experimental test, I actually also skip the head redo on Standby and let Standby to access Primary’s base cluster, disable the storage write actives).</p>
<h4 id="4-Summary"><a href="#4-Summary" class="headerlink" title="4. Summary"></a>4. Summary</h4><p>In this blog, I introduced a way to experiment the access of Primary’s buffer blocks, and hope this can be a topic for further study if someone want to learn PostgreSQL in deep.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2022/05/27/postgres-backup-restore-using-pg_rman/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/05/27/postgres-backup-restore-using-pg_rman/" class="post-title-link" itemprop="url">How to use pg_rman do backup and restore for PostgreSQL</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-05-27 01:00:00 / Modified: 13:45:53" itemprop="dateCreated datePublished" datetime="2022-05-27T01:00:00-07:00">2022-05-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/backup/" itemprop="url" rel="index">
                    <span itemprop="name">backup</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/backup/restore/" itemprop="url" rel="index">
                    <span itemprop="name">restore</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/backup/restore/incremental/" itemprop="url" rel="index">
                    <span itemprop="name">incremental</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-backup-restore-pg-rman.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>PostgreSQL is a very popular open-source relational database management system, and it is widely used in many different production environments. To maintain the production environment always functioning, you need to a lot tools, and one of the tools must to have been backup and restore. This blog is going to introduce one backup and restore tools designed for Postgres, i.e. pg_rman.</p>
<h4 id="2-What-is-pg-rman"><a href="#2-What-is-pg-rman" class="headerlink" title="2. What is pg_rman"></a>2. What is pg_rman</h4><p>pg_ramn is a free utility program designed to backup and restore PostgreSQL database. It takes a physical online backup of whole database cluster, archive WALs, and server logs, and restore a specific backup when the Postgres is offline. pg_rman not only supports backup a Primary Postgres server, but also can get backup from a standby server. If you want to learn more about pg_rman, you can [check it out at] (<a href="https://github.com/ossc-db/pg_rman.git" target="_blank" rel="noopener">https://github.com/ossc-db/pg_rman.git</a>).</p>
<h4 id="3-1-How-to-setup"><a href="#3-1-How-to-setup" class="headerlink" title="3.1. How to setup"></a>3.1. How to setup</h4><p>Depends on the Postgres version you are running, in this blog, we will use the latest pg_rman tagged with <code>V1.3.14</code> to demonstrate the backup and restore on PostgreSQL 14.</p>
<p>Now, assume you have the PostgreSQL 14 installed properly, then you can follow below steps to set up the Postgres server.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir pgdata_rman</span><br><span class="line">initdb  -D pgdata_rman</span><br><span class="line"></span><br><span class="line">echo &quot;archive_mode &#x3D; on&quot; &gt;&gt; pgdata_rman&#x2F;postgresql.conf</span><br><span class="line">echo &quot;archive_command &#x3D; &#39;cp %p &#x2F;media&#x2F;david&#x2F;disk1&#x2F;archive&#x2F;%f&#39;&quot; &gt;&gt; pgdata_rman&#x2F;postgresql.conf</span><br><span class="line">echo &quot;log_directory &#x3D; &#39;&#x2F;media&#x2F;david&#x2F;disk1&#x2F;pglog&#39;&quot; &gt;&gt; pgdata_rman&#x2F;postgresql.conf</span><br><span class="line">pg_ctl -D pgdata_rman -l pglog&#x2F;logfile start</span><br></pre></td></tr></table></figure>

<p>Then, we can check out the source code from github</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ossc-db&#x2F;pg_rman.git</span><br><span class="line">git checkout V1.3.14 -b local</span><br><span class="line">make clean &amp;&amp; make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>If no errors, then you have the pg_rman ready for the rest of the tests.</p>
<h5 id="3-2-Backup-and-restore"><a href="#3-2-Backup-and-restore" class="headerlink" title="3.2. Backup and restore"></a>3.2. Backup and restore</h5><p>Before running any backup and restore test, we need to initialize the backup for pg_rman to set the backup folder properly.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Initialize backup</span><br><span class="line">pg_rman init -B &#x2F;media&#x2F;david&#x2F;disk1&#x2F;backup_rman -D &#x2F;media&#x2F;david&#x2F;disk1&#x2F;pgdata_rman</span><br></pre></td></tr></table></figure>

<p>Once the backup folder has been initialized, then we can try to create a few tables and insert some data like below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">psql -d postgres -c &quot;CREATE TABLE abc (ID INT);&quot;</span><br><span class="line">psql -d postgres -c &quot;CREATE TABLE xyz (ID INT);&quot;</span><br><span class="line">psql -d postgres -c &quot;INSERT INTO abc VALUES (1);&quot;</span><br><span class="line">psql -d postgres -c &quot;INSERT INTO xyz VALUES (1);&quot;</span><br><span class="line">psql -d postgres -c &quot;SELECT count(*) from abc;&quot;</span><br><span class="line">psql -d postgres -c &quot;SELECT count(*) from xyz;&quot;</span><br></pre></td></tr></table></figure>

<p>Now, we can run our first backup with below commands,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Do a backup</span><br><span class="line">pg_rman backup --backup-mode&#x3D;full --with-serverlog -B &#x2F;media&#x2F;david&#x2F;disk1&#x2F;backup_rman -D &#x2F;media&#x2F;david&#x2F;disk1&#x2F;pgdata_rman -A &#x2F;media&#x2F;david&#x2F;disk1&#x2F;archive -S &#x2F;media&#x2F;david&#x2F;disk1&#x2F;pglog -p 5432 -d postgres</span><br></pre></td></tr></table></figure>
<p>here, we do a full backup to include everything, and with all the basic information for this full backup. pg_rman will ask you to valid the backup after each backup is done. So, to verify the backup we can simple run the command,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Validate</span><br><span class="line">pg_rman validate -B &#x2F;media&#x2F;david&#x2F;disk1&#x2F;backup_rman</span><br></pre></td></tr></table></figure>

<p>If the backup is valid, then we can insert some more data and run another backup. You can follow the steps below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">psql -d postgres -c &quot;INSERT INTO abc VALUES (2);&quot;</span><br><span class="line">psql -d postgres -c &quot;INSERT INTO xyz VALUES (2);&quot;</span><br><span class="line">psql -d postgres -c &quot;SELECT count(*) from abc;&quot;</span><br><span class="line">psql -d postgres -c &quot;SELECT count(*) from xyz;&quot;</span><br><span class="line"></span><br><span class="line">pg_rman backup --backup-mode&#x3D;full --with-serverlog -B &#x2F;media&#x2F;david&#x2F;disk1&#x2F;backup_rman -D &#x2F;media&#x2F;david&#x2F;disk1&#x2F;pgdata_rman -A &#x2F;media&#x2F;david&#x2F;disk1&#x2F;archive -S &#x2F;media&#x2F;david&#x2F;disk1&#x2F;pglog -p 5432 -d postgres </span><br><span class="line"></span><br><span class="line">#Validate</span><br><span class="line">pg_rman validate -B &#x2F;media&#x2F;david&#x2F;disk1&#x2F;backup_rman</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#### Insert more data</span><br><span class="line">psql -d postgres -c &quot;INSERT INTO abc VALUES (3);&quot;</span><br><span class="line">psql -d postgres -c &quot;INSERT INTO xyz VALUES (3);&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ pg_rman show -B &#x2F;media&#x2F;david&#x2F;disk1&#x2F;backup_rman</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> StartTime           EndTime              Mode    Size   TLI  Status </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">2022-05-27 13:05:30  2022-05-27 13:05:32  FULL    51MB     1  OK</span><br><span class="line">2022-05-27 13:05:28  2022-05-27 13:05:30  FULL    51MB     1  OK</span><br></pre></td></tr></table></figure>

<p>Now, we have two full backups first one has one record in each table, the second one has two records in each table, and the second backup we have inserted the third record to each table. If you query these two tables now, you can see below results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ psql -d postgres -c &quot;SELECT count(*) from abc;&quot;</span><br><span class="line"> count </span><br><span class="line">-------</span><br><span class="line">     3</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">$ psql -d postgres -c &quot;SELECT count(*) from xyz;&quot;</span><br><span class="line"> count </span><br><span class="line">-------</span><br><span class="line">     3</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>

<p>Assume we made a mistake on the third operation, and let’s stop the PostgreSQL server and try to restore back to the second backup stage.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Stop</span><br><span class="line">pg_ctl -D pgdata_rman -l pglog&#x2F;logfile stop</span><br><span class="line"> </span><br><span class="line">#Restore to target time</span><br><span class="line">pg_rman restore -B &#x2F;media&#x2F;david&#x2F;disk1&#x2F;backup_rman -D &#x2F;media&#x2F;david&#x2F;disk1&#x2F;pgdata_rman --recovery-target-time&#x3D;&quot;2022-05-27 13:05:32&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Restart</span><br><span class="line">pg_ctl -D pgdata_rman -l pglog&#x2F;logfile start</span><br><span class="line">$ psql -d postgres -c &quot;SELECT count(*) from abc;&quot;</span><br><span class="line"> count </span><br><span class="line">-------</span><br><span class="line">     2</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">$ psql -d postgres -c &quot;SELECT count(*) from xyz;&quot;</span><br><span class="line"> count </span><br><span class="line">-------</span><br><span class="line">     2</span><br><span class="line">(1 row)</span><br></pre></td></tr></table></figure>
<p>As you can see we back to the second backup stage, and each table has only two records.</p>
<h5 id="3-3-Anything-is-missing"><a href="#3-3-Anything-is-missing" class="headerlink" title="3.3. Anything is missing"></a>3.3. Anything is missing</h5><p>The pg_rman is a great free open-source tool for PostgreSQL users to backup and restore the database, however, there is one feature missed at this moment, i.e. targeted table restore. as a database administrator, one specific table restore can help reduce the risk on a production enrolment if only a single table need to be restored is a clear action.</p>
<h4 id="4-Summary"><a href="#4-Summary" class="headerlink" title="4. Summary"></a>4. Summary</h4><p>In this blog, we discussed the basic of PostgreSQL backup restore using a free open-source tool, i.e. pg_rman, and hope this piece information can help if you are looking for a free backup and restore solution for PostgreSQL.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2022/04/29/global-deadlock-detection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/04/29/global-deadlock-detection/" class="post-title-link" itemprop="url">global deadlock in a distributed database cluster</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-04-29 01:00:00 / Modified: 13:11:28" itemprop="dateCreated datePublished" datetime="2022-04-29T01:00:00-07:00">2022-04-29</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/deadlock/" itemprop="url" rel="index">
                    <span itemprop="name">deadlock</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/deadlock/global/" itemprop="url" rel="index">
                    <span itemprop="name">global</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/deadlock/global/fdw/" itemprop="url" rel="index">
                    <span itemprop="name">fdw</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/deadlock/global/fdw/distributed/" itemprop="url" rel="index">
                    <span itemprop="name">distributed</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/deadlock/global/fdw/distributed/cluster/" itemprop="url" rel="index">
                    <span itemprop="name">cluster</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-global-deadlock.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>Nowadays, supporting distributed transactions is a typical requirement for many use cases, however, the global deadlock detection is one of the key challenging issues if you plan to use PostgreSQL to setup a distributed database solution. There are many discussions about global deadlock, but this blog will provide you a step-by-step procedure about how to create such a global deadlock and share some thoughts based on personal experience.</p>
<h4 id="2-Deadlock"><a href="#2-Deadlock" class="headerlink" title="2. Deadlock"></a>2. Deadlock</h4><p>First of all, the basic concept of a deadlock is that Process A is trying to acquire Lock2 while it is holding Lock1 and Process B is trying to acquire Lock1 while it is holding Lock2 at the same moment. In this situation, Either Process A or Process B can’t not continue and they will wait for each other forever. Since PostgreSQL allows user transactions to request locks in any order, therefore, this kind of deadlock can happen. When this kind of deadlock is happening, there is no <code>win-win</code> solution, the only way to solve this locking issue is that one of the transactions has to abort and release the lock. </p>
<p>To address this deadlock issue, PostgreSQL has two key things built-in: 1) try to avoid the deadlock by having a lock waiting queue and sort the locks requests to avoid potential deadlock; 2) requires the transaction to abort if a deadlock detected; By having these two key designs, a deadlock happens within a single PostgreSQL server can be easily resolved. For more details information about the deadlock, you can refer to the official document at <a href="https://github.com/postgres/postgres/blob/master/src/backend/storage/lmgr/README" target="_blank" rel="noopener">src/backend/storage/lmgr/README</a>. In this blog, we call this kind of deadlock as local deadlock compared with the one (global deadlock) we are going to discuss more below.</p>
<p>The reason PostgreSQL can detect this local deadlock is because PostgreSQL knows all the locks information, and it can easily find a lock waiting cycle. In the source code, PostgreSQL defines a generic LOCKTAG data struct to let user transaction fill in different lock information. Here is how the LOCKTAG data struct is defined in PostgreSQL.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">typedef struct LOCKTAG</span><br><span class="line">&#123;</span><br><span class="line">    uint32 locktag_field1; &#x2F;* a 32-bit ID field *&#x2F;</span><br><span class="line">    uint32 locktag_field2; &#x2F;* a 32-bit ID field *&#x2F;</span><br><span class="line">    uint32 locktag_field3; &#x2F;* a 32-bit ID field *&#x2F;</span><br><span class="line">    uint16 locktag_field4; &#x2F;* a 16-bit ID field *&#x2F;</span><br><span class="line">    uint8 locktag_type; &#x2F;* see enum LockTagType *&#x2F;</span><br><span class="line">    uint8 locktag_lockmethodid; &#x2F;* lockmethod indicator *&#x2F;</span><br><span class="line">&#125; LOCKTAG;</span><br></pre></td></tr></table></figure>

<p>In PostgreSQL, there are about 10 Micros defined to address different locks in different use cases, and you can find the details by searching below key info.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#define SET_LOCKTAG_RELATION(locktag,dboid,reloid)</span><br><span class="line">#define SET_LOCKTAG_RELATION_EXTEND(locktag,dboid,reloid)</span><br><span class="line">#define SET_LOCKTAG_DATABASE_FROZEN_IDS(locktag,dboid)</span><br><span class="line">#define SET_LOCKTAG_PAGE(locktag,dboid,reloid,blocknum)</span><br><span class="line">#define SET_LOCKTAG_TUPLE(locktag,dboid,reloid,blocknum,offnum)</span><br><span class="line">#define SET_LOCKTAG_TRANSACTION(locktag,xid)</span><br><span class="line">#define SET_LOCKTAG_VIRTUALTRANSACTION(locktag,vxid)</span><br><span class="line">#define SET_LOCKTAG_SPECULATIVE_INSERTION(locktag,xid,token)</span><br><span class="line">#define SET_LOCKTAG_OBJECT(locktag,dboid,classoid,objoid,objsubid)</span><br><span class="line">#define SET_LOCKTAG_ADVISORY(locktag,id1,id2,id3,id4)</span><br></pre></td></tr></table></figure>

<p>In a distributed PostgreSQL deployment environment (typically, one or more Coordinator Nodes plus multiple Data Nodes), a deadlock can happen globally, like the one described in <a href="https://www.citusdata.com/blog/2017/08/31/databases-and-distributed-deadlocks-a-faq" target="_blank" rel="noopener">Databases and Distributed Deadlocks: A FAQ</a>. A deadlock triggered by Coordinator Node and caused multiple Data Nodes to wait for each other is called global deadlock or distributed deadlock. In this case, the original PostgreSQL can’t solve this problem as each Data Node doesn’t take this situation as a deadlock.</p>
<h4 id="3-How-to-create-a-global-deadlock"><a href="#3-How-to-create-a-global-deadlock" class="headerlink" title="3. How to create a global deadlock"></a>3. How to create a global deadlock</h4><p>To better understand the global deadlock issue, we can create a global deadlock by following below steps. First, you need to install postgres_fdw extension to setup a simple distributed database cluster by running below commands.</p>
<h5 id="3-1-Setup-a-simple-distributed-PostgreSQL-database-cluster"><a href="#3-1-Setup-a-simple-distributed-PostgreSQL-database-cluster" class="headerlink" title="3.1. Setup a simple distributed PostgreSQL database cluster"></a>3.1. Setup a simple distributed PostgreSQL database cluster</h5><p>Assume you have installed PostgreSQL or built your own binaries, and then initialize four PostgreSQL servers like below,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initdb -D &#x2F;tmp&#x2F;pgdata_cn1 -U $USER</span><br><span class="line">initdb -D &#x2F;tmp&#x2F;pgdata_cn2 -U $USER</span><br><span class="line">initdb -D &#x2F;tmp&#x2F;pgdata_dn1 -U $USER</span><br><span class="line">initdb -D &#x2F;tmp&#x2F;pgdata_dn2 -U $USER</span><br></pre></td></tr></table></figure>

<p>For each PostgreSQL database, edit the configuration files to set different port and cluster name. In this case, we have two Coordinator Nodes sitting on Port 50001 and 50002, and two Data Nodes listening on 60001 and 60002.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;tmp&#x2F;pgdata_dn1&#x2F;postgresql.conf</span><br><span class="line">  port &#x3D; 60001</span><br><span class="line">  cluster_name &#x3D; &#39;dn1&#39;</span><br><span class="line">vim &#x2F;tmp&#x2F;pgdata_dn2&#x2F;postgresql.conf</span><br><span class="line">  port &#x3D; 60002</span><br><span class="line">  cluster_name &#x3D; &#39;dn2&#39;</span><br><span class="line">vim &#x2F;tmp&#x2F;pgdata_cn1&#x2F;postgresql.conf</span><br><span class="line">  port &#x3D; 50001</span><br><span class="line">  cluster_name &#x3D; &#39;cn1&#39;</span><br><span class="line">vim &#x2F;tmp&#x2F;pgdata_cn2&#x2F;postgresql.conf</span><br><span class="line">  port &#x3D; 50002</span><br><span class="line">  cluster_name &#x3D; &#39;cn2&#39;</span><br></pre></td></tr></table></figure>
<p>Start all PostgreSQL servers.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pg_ctl -D &#x2F;tmp&#x2F;pgdata_cn1 -l &#x2F;tmp&#x2F;logfile_cn1 start</span><br><span class="line">pg_ctl -D &#x2F;tmp&#x2F;pgdata_cn2 -l &#x2F;tmp&#x2F;logfile_cn2 start</span><br><span class="line">pg_ctl -D &#x2F;tmp&#x2F;pgdata_dn1 -l &#x2F;tmp&#x2F;logfile_dn1 start</span><br><span class="line">pg_ctl -D &#x2F;tmp&#x2F;pgdata_dn2 -l &#x2F;tmp&#x2F;logfile_dn2 start</span><br></pre></td></tr></table></figure>

<h5 id="3-2-Setup-the-Data-Nodes"><a href="#3-2-Setup-the-Data-Nodes" class="headerlink" title="3.2. Setup the Data Nodes"></a>3.2. Setup the Data Nodes</h5><p>Run below commands to create table t on two Data Nodes,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psql -d postgres -U $USER -p 60001 -c &quot;create table t(a int, b text);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 60002 -c &quot;create table t(a int, b text);&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-3-Setup-the-Coordinator-Nodes"><a href="#3-3-Setup-the-Coordinator-Nodes" class="headerlink" title="3.3. Setup the Coordinator Nodes"></a>3.3. Setup the Coordinator Nodes</h5><p>Coordinator Node setup is a little complicated. Here, we are using the postgres_fdw extension to create a simple distributed PostgreSQL database cluster, therefore, you need to follow below steps to setup the postgres_fdw extension, user mappings, and foreign servers and tables.<br>Setup the extension, foreign servers, user mappings, and tables on Coordinator Node 1.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;create extension postgres_fdw;&quot;</span><br><span class="line"></span><br><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;create server s1 foreign data wrapper postgres_fdw options (dbname &#39;postgres&#39;, host &#39;127.0.0.1&#39;, port &#39;60001&#39;);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;create server s2 foreign data wrapper postgres_fdw options (dbname &#39;postgres&#39;, host &#39;127.0.0.1&#39;, port &#39;60002&#39;);&quot;</span><br><span class="line"></span><br><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;create user mapping for $USER server s1 options( user &#39;$USER&#39;);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;create user mapping for $USER server s2 options( user &#39;$USER&#39;);&quot;</span><br><span class="line"></span><br><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;create table t(a int, b text) partition by range(a);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;create foreign table t_s1 partition of t for values from (1000) to (1999) server s1 options(schema_name &#39;public&#39;, table_name &#39;t&#39;);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;create foreign table t_s2 partition of t for values from (2000) to (2999) server s2 options(schema_name &#39;public&#39;, table_name &#39;t&#39;);&quot;</span><br></pre></td></tr></table></figure>

<p>Setup the extension, foreign servers, user mappings, and tables on Coordinator Node 2.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;create extension postgres_fdw;&quot;</span><br><span class="line"></span><br><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;create server s1 foreign data wrapper postgres_fdw options (dbname &#39;postgres&#39;, host &#39;127.0.0.1&#39;, port &#39;60001&#39;);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;create server s2 foreign data wrapper postgres_fdw options (dbname &#39;postgres&#39;, host &#39;127.0.0.1&#39;, port &#39;60002&#39;);&quot;</span><br><span class="line"></span><br><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;create user mapping for $USER server s1 options( user &#39;$USER&#39;);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;create user mapping for $USER server s2 options( user &#39;$USER&#39;);&quot;</span><br><span class="line"></span><br><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;create table t(a int, b text) partition by range(a);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;create foreign table t_s1 partition of t for values from (1000) to (1999) server s1 options(schema_name &#39;public&#39;, table_name &#39;t&#39;);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;create foreign table t_s2 partition of t for values from (2000) to (2999) server s2 options(schema_name &#39;public&#39;, table_name &#39;t&#39;);&quot;</span><br></pre></td></tr></table></figure>

<h5 id="3-4-Create-a-global-deadlock"><a href="#3-4-Create-a-global-deadlock" class="headerlink" title="3.4. Create a global deadlock"></a>3.4. Create a global deadlock</h5><p>Now, after you have setup this simple distributed PostgreSQL database cluster, you can run below commands in two different psql sessions/consoles to create a global deadlock.</p>
<p>First, insert one tuple on each Data Node.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">psql -d postgres -U $USER -p 50001 -c &quot;insert into t values(1001, &#39;session-1&#39;);&quot;</span><br><span class="line">psql -d postgres -U $USER -p 50002 -c &quot;insert into t values(2001, &#39;session-2&#39;);&quot;</span><br></pre></td></tr></table></figure>
<p>Second, start two different psql consoles and run the tuple update based on below sequence indicated by (x). </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">psql -d postgres -U $USER -p 50001</span><br><span class="line">begin;</span><br><span class="line">update t set b &#x3D; &#39;session-11&#39; where a &#x3D; 1001;     (1)</span><br><span class="line"></span><br><span class="line">update t set b &#x3D; &#39;session-11&#39; where a &#x3D; 2001;     (4)</span><br><span class="line"></span><br><span class="line">psql -d postgres -U $USER -p 50002</span><br><span class="line">begin;</span><br><span class="line">update t set b &#x3D; &#39;session-22&#39; where a &#x3D; 2001;     (2)</span><br><span class="line"></span><br><span class="line">update t set b &#x3D; &#39;session-22&#39; where a &#x3D; 1001;     (3)</span><br></pre></td></tr></table></figure>

<p>After, the update query (4) has been executed, you will end up like below waiting situation, </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# begin;</span><br><span class="line">BEGIN</span><br><span class="line">postgres&#x3D;*# update t set b &#x3D; &#39;session-11&#39; where a &#x3D; 1001;</span><br><span class="line">UPDATE 1</span><br><span class="line">postgres&#x3D;*# update t set b &#x3D; &#39;session-11&#39; where a &#x3D; 2001;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">postgres&#x3D;# begin;</span><br><span class="line">BEGIN</span><br><span class="line">postgres&#x3D;*# update t set b &#x3D; &#39;session-22&#39; where a &#x3D; 2001;</span><br><span class="line">UPDATE 1</span><br><span class="line">postgres&#x3D;*# </span><br><span class="line">postgres&#x3D;*# update t set b &#x3D; &#39;session-22&#39; where a &#x3D; 1001;</span><br></pre></td></tr></table></figure>

<p>If you grep postgres process using below command, and you will find two separate postgres from two different Data Node are in <code>UPDATE waiting</code>, and this will last forever.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">david:postgres$ ps -ef |grep postgres |grep waiting</span><br><span class="line">david     2811  2768  0 11:15 ?        00:00:00 postgres: dn1: david postgres 127.0.0.1(45454) UPDATE waiting</span><br><span class="line">david     2812  2740  0 11:15 ?        00:00:00 postgres: dn2: david postgres 127.0.0.1(55040) UPDATE waiting</span><br></pre></td></tr></table></figure>

<p>When the global deadlock is happening above, you can check the waiting process in details by gdb attaching to any of them. If you dig into the source code, you can find out that this global deadlock is actually related with <code>SET_LOCKTAG_TRANSACTION</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#define SET_LOCKTAG_TRANSACTION(locktag,xid) \</span><br><span class="line">((locktag).locktag_field1 &#x3D; (xid), \</span><br><span class="line">(locktag).locktag_field2 &#x3D; 0, \</span><br><span class="line">(locktag).locktag_field3 &#x3D; 0, \</span><br><span class="line">(locktag).locktag_field4 &#x3D; 0, \</span><br><span class="line">(locktag).locktag_type &#x3D; LOCKTAG_TRANSACTION, \</span><br><span class="line">(locktag).locktag_lockmethodid &#x3D; DEFAULT_LOCKMETHOD)</span><br></pre></td></tr></table></figure>

<h4 id="4-How-to-solve-the-problem"><a href="#4-How-to-solve-the-problem" class="headerlink" title="4. How to solve the problem"></a>4. How to solve the problem</h4><p>There are many discussions about global deadlock detection, like the one mentioned above <a href="https://www.citusdata.com/blog/2017/08/31/databases-and-distributed-deadlocks-a-faq" target="_blank" rel="noopener">Databases and Distributed Deadlocks: A FAQ</a>, which has some recommendations like <code>Predicate Locks</code> and <code>Wait-Die or Wound-Wait</code><br>And a very detailed one about how to detect a global deadlock at <a href="https://www.enterprisedb.com/blog/postgresql-and-deadlock-detection-spanning-multiple-databases" target="_blank" rel="noopener">PostgreSQL and Deadlock Detection Spanning Multiple Databases</a>, which recommends using a <code>Global Wait-for-Graph</code> to detect it.  </p>
<p>Another approach is that instead of avoid the problems, or using wait-for-graph to find a cycle, we can also consider to have an independent program or even a simple database to help check if there is a global deadlock. Sometimes, the issue is hard to solve is because it is hard to get all the information. The reason we can easily see a deadlock caused by one or multiple Coordinator Nodes is because we take one step back and look at the situation as a whole picture.</p>
<h4 id="5-Summary"><a href="#5-Summary" class="headerlink" title="5. Summary"></a>5. Summary</h4><p>In this blog, we discussed the basic global deadlock issue, setup a simple distributed database cluster using postgres_fdw and demonstrated a global deadlock. We also discussed different approaches to either avoid this global deadlock or solve it in different ways.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2022/03/31/parallel-abort-in-postgres-fdw/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/03/31/parallel-abort-in-postgres-fdw/" class="post-title-link" itemprop="url">parallel commit in postgres fdw</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-03-31 01:00:00" itemprop="dateCreated datePublished" datetime="2022-03-31T01:00:00-07:00">2022-03-31</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-04-05 11:19:37" itemprop="dateModified" datetime="2022-04-05T11:19:37-07:00">2022-04-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/parallel/" itemprop="url" rel="index">
                    <span itemprop="name">parallel</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/parallel/commit/" itemprop="url" rel="index">
                    <span itemprop="name">commit</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/parallel/commit/fdw/" itemprop="url" rel="index">
                    <span itemprop="name">fdw</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-parallel-commit.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>PostgreSQL is one of the greatest open source databases, not only because of the extensibility and SQL compliance but also the evolution of new features. For example, in postgres_fdw, there is a new feature <code>parallel commit</code> has been added into the main branch and will be released in PG15. This blog is for a quick taste of this new feature.</p>
<h4 id="2-how-parallel-commit-works"><a href="#2-how-parallel-commit-works" class="headerlink" title="2. how parallel commit works"></a>2. how parallel commit works</h4><p>If you are a PostgreSQL database developer or if your internal database is built based on PostgreSQL database, and especially you have some applications which are related with the extension <code>postgres_fdw</code>, then you might wnat to take a look at this <code>parallel commit</code> feature. This new feature is committed just a month ago. It may help you on solving some performance issues, or as a reference if you are planning to build any parallel features on a postgres_fdw based solution. Here is the details about this <code>parallel commit</code> for postgres_fdw.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">commit 04e706d4238f98a98e1c0b1a02db9d4280b96f04</span><br><span class="line">Author: Etsuro Fujita &lt;efujita@postgresql.org&gt;</span><br><span class="line">Date:   Thu Feb 24 14:30:00 2022 +0900</span><br><span class="line"></span><br><span class="line">    postgres_fdw: Add support for parallel commit.</span><br><span class="line">    </span><br><span class="line">    postgres_fdw commits remote (sub)transactions opened on remote server(s)</span><br><span class="line">    in a local (sub)transaction one by one when the local (sub)transaction</span><br><span class="line">    commits.  This patch allows it to commit the remote (sub)transactions in</span><br><span class="line">    parallel to improve performance.  This is enabled by the server option</span><br><span class="line">    &quot;parallel_commit&quot;.  The default is false.</span><br></pre></td></tr></table></figure>

<p>By default, this parallel commit feature is turned off. If you want to try it you can simply turn it on by </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER SERVER loopback OPTIONS (ADD parallel_commit &#39;true&#39;);</span><br></pre></td></tr></table></figure>
<p>Once this <code>parallel commit</code> option is on for those foreign servers involved in a local transaction and when this local transaction commits, the opened remote transaction on those foreign servers will be committed in parallel. By providing this option, PostgreSQL community expects some performance improvement when multiple foreign servers involved in a transaction. This parallel commit feature can be useful for some applications on distributed PostgreSQL database clusters using postgre_fdw.</p>
<p>To verify the performance improvement, you can simply test it for before and after using below commands,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">psql -d postgres -p 5432 -Atq &lt;&lt;EOT</span><br><span class="line">\timing on</span><br><span class="line">BEGIN;</span><br><span class="line">SAVEPOINT s;</span><br><span class="line">INSERT INTO ft1 VALUES (10, 10);</span><br><span class="line">INSERT INTO ft2 VALUES (20, 20);</span><br><span class="line">RELEASE SAVEPOINT s;</span><br><span class="line">COMMIT;</span><br><span class="line">EOT</span><br></pre></td></tr></table></figure>

<p>According to the initial discussion for this <code>parallel commit</code> feature, below are some performance numbers for your reference.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">* RELEASE</span><br><span class="line">  parallel_commit&#x3D;0: 0.385 ms</span><br><span class="line">  parallel_commit&#x3D;1: 0.221 ms</span><br><span class="line"></span><br><span class="line">* COMMIT</span><br><span class="line">  parallel_commit&#x3D;0: 1.660 ms</span><br><span class="line">  parallel_commit&#x3D;1: 0.861 ms</span><br></pre></td></tr></table></figure>

<p>To disable this feature, you can run a command like below,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ALTER SERVER loopback OPTIONS (DROP parallel_commit);</span><br></pre></td></tr></table></figure>


<h4 id="3-Summary"><a href="#3-Summary" class="headerlink" title="3. Summary"></a>3. Summary</h4><p>In this blog, we discussed the parallel commit feature recently added to postgres_fdw. When you apply this feature to your production servers you might need to be careful as it is mentioned in the document, <code>this option might increase the remote server’s load when the local (sub)transaction commits</code>. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2022/02/28/acquire-a-lightweight-lock-in-deep/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/28/acquire-a-lightweight-lock-in-deep/" class="post-title-link" itemprop="url">A snippet to acquire a Lightweight lock</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-02-28 00:00:00 / Modified: 14:15:33" itemprop="dateCreated datePublished" datetime="2022-02-28T00:00:00-08:00">2022-02-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/Lightweight-lock/" itemprop="url" rel="index">
                    <span itemprop="name">Lightweight lock</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/Lightweight-lock/performance/" itemprop="url" rel="index">
                    <span itemprop="name">performance</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/Lightweight-lock/performance/shared/" itemprop="url" rel="index">
                    <span itemprop="name">shared</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/Lightweight-lock/performance/shared/exclusive/" itemprop="url" rel="index">
                    <span itemprop="name">exclusive</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-lwlock.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>Recently, I was working on an internal issue related with buffer manager in PostgreSQL, and I saw a typical use of the Lightweight lock in buffer manager like below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1   INIT_BUFFERTAG(newTag, smgr_rnode.node, forkNum, blockNum);</span><br><span class="line">2   newHash &#x3D; BufTableHashCode(&amp;newTag);</span><br><span class="line">3   newPartitionLock &#x3D; BufMappingPartitionLock(newHash);</span><br><span class="line">4   LWLockAcquire(newPartitionLock, LW_SHARED);</span><br><span class="line">5   buf_id &#x3D; BufTableLookup(&amp;newTag, newHash);</span><br><span class="line">6   LWLockRelease(newPartitionLock);</span><br></pre></td></tr></table></figure>

<p>Basically, when the buffer manger needs to access a buffer block using buffer tag, it will have to acquire a lightweight lock in either shared or exclusive mode, then find the buffer block and then release the lightweight lock.</p>
<p>Since the buffer manager is shared among multiple backends and a buffer block is accessed very often, this snippet has to be designed to protect the data consistency for read and write and no impact on performance.</p>
<p>This blog will explain how this snippet works in PostgreSQL and emphasize a little bit more on the lightweight lock acquire.</p>
<h4 id="2-how-to-use-snapshot-public-functions"><a href="#2-how-to-use-snapshot-public-functions" class="headerlink" title="2. how to use snapshot public functions"></a>2. how to use snapshot public functions</h4><p>Now, let’s go through the snippet above line by line.<br>The first line simply uses a Macro to initialize a buffer tag using those five numbers. Here, <code>INIT_BUFFERTAG</code> is a macro defines like below,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#define INIT_BUFFERTAG(a,xx_rnode,xx_forkNum,xx_blockNum) \</span><br><span class="line">( \</span><br><span class="line">    (a).rnode &#x3D; (xx_rnode), \</span><br><span class="line">    (a).forkNum &#x3D; (xx_forkNum), \</span><br><span class="line">    (a).blockNum &#x3D; (xx_blockNum) \</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>After the macro call, the newTag has been assigned with those five numbers, i.e., table space number, database number, relation number, fork number (data, fsm or visibility map etc), and the block number (each block is 8k) within the actual file;</p>
<p>The second line <code>newHash = BufTableHashCode(&amp;newTag);</code> generates a hash number based on the buffer tag. Where, The function <code>BufTableHashCode</code> computes the hash code associated with given buffer tag in the global shared buffer hash table, and return a unsigned integer.</p>
<p>The third line retrieves a partition lock within the locks pool used an unsigned integer hash number mod the total number of partition locks (default 128).<br>Again, the function BufMappingPartitionLock is a predefined macro and is showing below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define BufMappingPartitionLock(hashcode) \</span><br><span class="line">    (&amp;MainLWLockArray[BUFFER_MAPPING_LWLOCK_OFFSET + \</span><br><span class="line">        BufTableHashPartition(hashcode)].lock)</span><br></pre></td></tr></table></figure>

<p>It will return a lock in <code>MainLWLockArray</code> lightweight locks array. Where the <code>BUFFER_MAPPING_LWLOCK_OFFSET</code> is number of dedicated lightweight locks defined in <code>lwlocknames.txt</code> file. The number of partition lightweight locks are 128 locks located after these dedicated locks defined in these main lightweight locks array. Here, the macro <code>BufTableHashPartition</code> is to make sure it always returns a lock in the partition locks pool for any given hash number.</p>
<p>The fourth line to is to acquire the lightweight lock with a very efficient algorithm. This <code>LWLockAcquire</code> will help return a lightweight lock in the specified mode, i.e., shared (for read only operation) or exclusive (for write operation). This function returns <code>true</code> if the lock was available immediately, <code>false</code> if it has to sleep and wait.<br>Inside this <code>LWLockAcquire</code>, there are many considerations, but I want to emphasize one smart c implementation in the function <code>LWLockAttemptLock</code>, and I believe you can use this similar idea as a design pattern to design other CPU and Memory sensitive logic in your applications.<br>As you can see below is the key implementation of this shared and exclusive lock.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (mode &#x3D;&#x3D; LW_EXCLUSIVE)</span><br><span class="line">&#123;</span><br><span class="line">    lock_free &#x3D; (old_state &amp; LW_LOCK_MASK) &#x3D;&#x3D; 0;</span><br><span class="line">    if (lock_free)</span><br><span class="line">        desired_state +&#x3D; LW_VAL_EXCLUSIVE;</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    lock_free &#x3D; (old_state &amp; LW_VAL_EXCLUSIVE) &#x3D;&#x3D; 0;</span><br><span class="line">    if (lock_free)</span><br><span class="line">        desired_state +&#x3D; LW_VAL_SHARED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This implementation involves three macros: <code>LW_LOCK_MASK</code>, <code>LW_VAL_EXCLUSIVE</code> and <code>LW_VAL_SHARED</code>, where <code>LW_LOCK_MASK</code> is a consistent number, i.e., <code>0xFFFFFF</code>, used in bit operation. If any lower 24 bits has a one, then it means the lock is held in either shared or exclusive mode. In other words, someone is still reading the data, if you want the update the data, please wait. If the all lower 24 bits are zeros, then it will be assigned to a big number <code>LW_VAL_EXCLUSIVE</code>, i.e., <code>0x800000</code>, which indicates the lock is used as exclusive. If you want to acquire this lock in shared mode, then as long as the lock is not held by someone in exclusive mode and it is not held more than <code>0x7FFFFF</code>, then you can acquire one shared lock and the number of usages will be simple increase by one, i.e., <code>LW_VAL_SHARED</code>. Of course, how many shared locks can be held at the same time is limited by other parameters.</p>
<p>Here is the definition of these three macros.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define LW_LOCK_MASK                ((uint32) ((1 &lt;&lt; 25)-1))</span><br><span class="line">#define LW_VAL_EXCLUSIVE            ((uint32) 1 &lt;&lt; 24)</span><br><span class="line">#define LW_VAL_SHARED               1</span><br></pre></td></tr></table></figure>

<p>The fifth line looks up the buffer id using the given buffer tag and hash code.<br>Once you have acquired the lock, work on the operations immediately depends on your application, but keep in mind the lightweight lock is designed to be held only in a short period. </p>
<p>The sixth line release the lock back to the partition lock pool.<br>After you finished your operations either read or write, then use this LWLockRelease function to release the lock as soon as you can, so you don’t block other processes too long especially if there is a write operation need to acquire this lock in exclusive mode. </p>
<h4 id="3-Summary"><a href="#3-Summary" class="headerlink" title="3. Summary"></a>3. Summary</h4><p>In this blog, we discussed a typical snippet which uses a lightweight lock in PostgreSQL, and explained one of the most efficient piece of code implemented for Lightweight lock in PostgreSQL, i.e., LWLockAcquire. I hope this can help when you want to achieve a similar result in your own design.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2022/01/28/transaction-id-and-snapshot-information-functions/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2022/01/28/transaction-id-and-snapshot-information-functions/" class="post-title-link" itemprop="url">Transaction ID and Snapshot information functions</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-01-28 00:00:00 / Modified: 15:54:23" itemprop="dateCreated datePublished" datetime="2022-01-28T00:00:00-08:00">2022-01-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/transaction-id/" itemprop="url" rel="index">
                    <span itemprop="name">transaction id</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/transaction-id/snapshot/" itemprop="url" rel="index">
                    <span itemprop="name">snapshot</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/transaction-id/snapshot/public-function/" itemprop="url" rel="index">
                    <span itemprop="name">public function</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-snapshot.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>I recently investigated one internal issue which was related with snapshot and found there were some changes on transaction id and snapshot information functions in PostgreSQL. Here, I am trying to share what I have learned. </p>
<p>Before PostgreSQL 13, all transaction id and snapshot related public functions were named as txid_xxx_yyy, such as,<br>txid_current(), which returns the current toplevel transaction ID.<br>txid_current_if_assigned(), which is similar to txid_current() but doesn’t assign a new xid if there isn’t one.<br>txid_current_snapshot(), which returns current snapshot in txid format with only top-transaction XIDs.<br>txid_status(), which reports the status of a recent transaction ID.</p>
<p>Started from PostgreSQL 13, the naming convention of these snapshot public functions txid_xxx_yyy has been changed to something like, pg_xxx_xact_yyy correspondingly. For example, txid_current() is replaced by pg_current_xact_id(), and txid_current_if_assigned() has been renamed to pg_current_xact_id_if_assigned(), etc.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">commit 4c04be9b05ad2ec5acd27c3417bf075c13cab134 (HEAD -&gt; xid8funcs)</span><br><span class="line">Author: Thomas Munro &lt;tmunro@postgresql.org&gt;</span><br><span class="line">Date:   Tue Apr 7 11:33:56 2020 +1200</span><br><span class="line"></span><br><span class="line">    Introduce xid8-based functions to replace txid_XXX.</span><br><span class="line">    </span><br><span class="line">    The txid_XXX family of fmgr functions exposes 64 bit transaction IDs to</span><br><span class="line">    users as int8.  Now that we have an SQL type xid8 for FullTransactionId,</span><br><span class="line">    define a new set of functions including pg_current_xact_id() and</span><br><span class="line">    pg_current_snapshot() based on that.  Keep the old functions around too,</span><br><span class="line">    for now.</span><br><span class="line">    </span><br><span class="line">    It&#39;s a bit sneaky to use the same C functions for both, but since the</span><br><span class="line">    binary representation is identical except for the signedness of the</span><br><span class="line">    type, and since older functions are the ones using the wrong signedness,</span><br><span class="line">    and since we&#39;ll presumably drop the older ones after a reasonable period</span><br><span class="line">    of time, it seems reasonable to switch to FullTransactionId internally</span><br><span class="line">    and share the code for both.</span><br></pre></td></tr></table></figure>

<p>Introduce xid8-based functions to replace txid_XXX.</p>
<p>An official documentation regarding these functions can be found at <a href="https://www.postgresql.org/docs/14/functions-info.html" target="_blank" rel="noopener">Transaction ID and Snapshot Information Functions</a> at Table 9.76. Transaction ID and Snapshot Information Functions.</p>
<h4 id="2-how-to-use-snapshot-public-functions"><a href="#2-how-to-use-snapshot-public-functions" class="headerlink" title="2. how to use snapshot public functions"></a>2. how to use snapshot public functions</h4><p>Since PostgreSQL has provided us so many public functions for end users to check the transaction id and snapshot information in details, sometimes, we need to know how to use these funtions in a simple query to have better understanding of the ongoing transactions, visibilities, and snapshots. Here, I have some simple examples to share.</p>
<p>first, let’s create a simple table like below,<br>postgres=# create table tbl01 (a int, b text);<br>CREATE TABLE</p>
<p>to find out the current transaction id, you can simply do <code>select pg_current_xact_id();</code> in a psql console,<br>postgres=# select pg_current_xact_id();<br> pg_current_xact_id </p>
<hr>
<pre><code>734</code></pre><p>(1 row)<br>Here, the number 734 is the current transaction id. Each time, when you run such a query, the transaction id will increase by one.</p>
<p>postgres=# select pg_current_xact_id();<br> pg_current_xact_id </p>
<hr>
<pre><code>735</code></pre><p>(1 row)</p>
<p>If you want to know the current transaction id, then use function <code>pg_current_xact_id_if_assigned()</code>. Obversely, as the document indicated, if you are not within a transaction, this function won’t return any transaction id.<br>postgres=# select pg_current_xact_id_if_assigned();<br> pg_current_xact_id_if_assigned </p>
<hr>
<p>(1 row)</p>
<p>However, if start a transaction with begin, followed a simple insert query like below, and then run the function <code>pg_current_xact_id_if_assigned()</code> again, you should be able to find out your current transaction id.<br>postgres=# begin ;<br>BEGIN<br>postgres=<em># insert into tbl01 values(1,’hello world’);<br>INSERT 0 1<br>postgres=</em># select pg_current_xact_id_if_assigned();<br> pg_current_xact_id_if_assigned </p>
<hr>
<pre><code>736</code></pre><p>(1 row)</p>
<p>The function <code>pg_current_snapshot()</code> will return current top level snapshot in a format like, <code>xmin:xmax:xid1,xid2</code>. For example,<br>postgres=*#  select pg_current_snapshot();<br> pg_current_snapshot </p>
<hr>
<p> 736:736:<br>(1 row<br>In this case, the PostgreSQL server has only one ongoing transaction which is 736.   </p>
<p>One of the use cases for end user is that a user may want to check the tuples visibilities using pg_current_snapshot and pg_current_xact_id_if_assigned. For example, start two psql consoles with begin and followed by one simple insert operation, then check the current transaction id and current snapshots.</p>
<p>postgres=*# select pg_current_xact_id_if_assigned();<br> pg_current_xact_id_if_assigned </p>
<hr>
<pre><code>736</code></pre><p>(1 row)</p>
<p>postgres=*#  select pg_current_snapshot();<br> pg_current_snapshot </p>
<hr>
<p> 736:739:737<br>(1 row)<br>In the first console, it tells that the current transactions id is 736, and there is another ongoing transaction 737 and any tuples update made by transaction 737 is not visibile to this console yet.</p>
<p>postgres=*# select pg_current_xact_id_if_assigned();<br> pg_current_xact_id_if_assigned </p>
<hr>
<pre><code>737</code></pre><p>(1 row)</p>
<p>postgres=*# select pg_current_snapshot();<br> pg_current_snapshot </p>
<hr>
<p> 736:739:736<br>(1 row)</p>
<p>If you check the assigned transaction id and current snapshot in the second console, it will tell you a similar information. With these two public fucntions and plus an extension pageinspect, it can help debug the tuple visibilities issue.</p>
<h4 id="3-Summary"><a href="#3-Summary" class="headerlink" title="3. Summary"></a>3. Summary</h4><p>In this blog, we discussed the changes made for those transaction id and snapshot public functions, and shared a few simple queries about how to use these snapshots related public funtions. It might be useful if you want to have a better understanding of the ongoing transactions and snapshots.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2021/11/26/how-to-run-a-specific-regression-test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/11/26/how-to-run-a-specific-regression-test/" class="post-title-link" itemprop="url">How to run a specific regression test</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-11-26 00:00:00 / Modified: 16:26:44" itemprop="dateCreated datePublished" datetime="2021-11-26T00:00:00-08:00">2021-11-26</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/regression-TAP/" itemprop="url" rel="index">
                    <span itemprop="name">regression TAP</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/regression-TAP/test/" itemprop="url" rel="index">
                    <span itemprop="name">test</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-tap-test.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>I have been working on an internal project based on PostgreSQL for a while, and from time to time, I need to run some specific test cases to verify my changes. Here, I want to shared a tip to run a specific regression TAP test quickly, especially, when you are focusing on a particular bug and you know which test case can help verify the fix. A details document about the regression test can be found at <a href="https://www.postgresql.org/docs/14/regress-run.html" target="_blank" rel="noopener">Running the Tests</a>.</p>
<h4 id="2-Regression-test"><a href="#2-Regression-test" class="headerlink" title="2. Regression test"></a>2. Regression test</h4><p>PostgreSQL provides a comprehensive set of regression tests to verify the SQL implementation embedded in PostgreSQL as well as the extended capabilities of PostgreSQL. Whenever you make some changes, you should run these existing test cases to make sure your change doesn’t break any existing features. Other than these regression tests, there are some special features using a test framework call TAP test. For example, <code>kerberos</code>, <code>ssl</code>, <code>recovery</code> etc.</p>
<p>If you want to run these tests, you have to make sure the option <code>--enable-tap-tests</code> has been configured. for example,<br><code>./configure --prefix=$HOME/pgapp --enable-tap-tests --enable-debug CFLAGS=&quot;-g3 -O0 -fno-omit-frame-pointer&quot;</code></p>
<p>You can run the TAP test using either <code>make check</code> or <code>make installcheck</code>, but compared with those non-TAP tests, the different is that these TAP tests will always start a test server even you run <code>make installcheck</code>. Because of this different, some tests may take a longer time than you expected, and even worse, if some test cases failed in the middle then the entire test will stop, and your test cases may never get the chance to run. For example, I changed somethings related to the recovery features, and those changes suppose to be tested by test cases <code>021_row_visibility.pl</code> and <code>025_stuck_on_old_timeline.pl</code>, but whenever I run <code>make check</code> or <code>make installcheck</code>, it ends up with something like below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">t&#x2F;001_stream_rep.pl .................. ok     </span><br><span class="line">t&#x2F;002_archiving.pl ................... ok   </span><br><span class="line">t&#x2F;003_recovery_targets.pl ............ ok   </span><br><span class="line">t&#x2F;004_timeline_switch.pl ............. ok   </span><br><span class="line">t&#x2F;005_replay_delay.pl ................ ok   </span><br><span class="line">t&#x2F;006_logical_decoding.pl ............ ok     </span><br><span class="line">t&#x2F;007_sync_rep.pl .................... ok     </span><br><span class="line">t&#x2F;008_fsm_truncation.pl .............. ok   </span><br><span class="line">t&#x2F;009_twophase.pl .................... ok     </span><br><span class="line">t&#x2F;010_logical_decoding_timelines.pl .. ok     </span><br><span class="line">t&#x2F;011_crash_recovery.pl .............. ok   </span><br><span class="line">t&#x2F;012_subtransactions.pl ............. ok     </span><br><span class="line">t&#x2F;013_crash_restart.pl ............... ok     </span><br><span class="line">t&#x2F;014_unlogged_reinit.pl ............. ok     </span><br><span class="line">t&#x2F;015_promotion_pages.pl ............. ok   </span><br><span class="line">t&#x2F;016_min_consistency.pl ............. ok   </span><br><span class="line">t&#x2F;017_shm.pl ......................... ok   </span><br><span class="line">t&#x2F;018_wal_optimize.pl ................ ok     </span><br><span class="line">t&#x2F;019_replslot_limit.pl .............. 11&#x2F;20 Bailout called.  Further testing stopped:  pg_ctl start failed</span><br><span class="line">FAILED--Further testing stopped: pg_ctl start failed</span><br><span class="line">Makefile:23: recipe for target &#39;check&#39; failed</span><br><span class="line">make: *** [check] Error 255</span><br></pre></td></tr></table></figure>
<p>Now, <code>019_replslot_limit.pl</code> always failed in the middle, but those test cases to verify my changes haven’t got the chance to run yet.</p>
<h4 id="3-How-to-run-a-specific-test"><a href="#3-How-to-run-a-specific-test" class="headerlink" title="3. How to run a specific test?"></a>3. How to run a specific test?</h4><p>To run a specific test cases, the key is to use a variable <code>PROVE_TESTS</code> provided by PostgreSQL. Details can be found at <a href="https://www.postgresql.org/docs/14/regress-tap.html" target="_blank" rel="noopener">TAP Tests</a>. This <code>PROVE_TESTS</code> variable allow to define a whitespace separated list of paths to run the specified subset of tests instead of the default t/*.pl. For example: in above case, you can run <code>make check PROVE_TESTS=&#39;t/021_row_visibility.pl t/025_stuck_on_old_timeline.pl&#39;</code>. It will run these two test cases directly. The output is something like below.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">recovery$ make check PROVE_TESTS&#x3D;&#39;t&#x2F;021_row_visibility.pl t&#x2F;025_stuck_on_old_timeline.pl&#39; </span><br><span class="line">make -C ..&#x2F;..&#x2F;..&#x2F;src&#x2F;backend generated-headers</span><br><span class="line">make[1]: Entering directory &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;backend&#39;</span><br><span class="line">make -C catalog distprep generated-header-symlinks</span><br><span class="line">make[2]: Entering directory &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;backend&#x2F;catalog&#39;</span><br><span class="line">make[2]: Nothing to be done for &#39;distprep&#39;.</span><br><span class="line">make[2]: Nothing to be done for &#39;generated-header-symlinks&#39;.</span><br><span class="line">make[2]: Leaving directory &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;backend&#x2F;catalog&#39;</span><br><span class="line">make -C utils distprep generated-header-symlinks</span><br><span class="line">make[2]: Entering directory &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;backend&#x2F;utils&#39;</span><br><span class="line">make[2]: Nothing to be done for &#39;distprep&#39;.</span><br><span class="line">make[2]: Nothing to be done for &#39;generated-header-symlinks&#39;.</span><br><span class="line">make[2]: Leaving directory &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;backend&#x2F;utils&#39;</span><br><span class="line">make[1]: Leaving directory &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;backend&#39;</span><br><span class="line">rm -rf &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#39;&#x2F;tmp_install</span><br><span class="line">&#x2F;bin&#x2F;mkdir -p &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#39;&#x2F;tmp_install&#x2F;log</span><br><span class="line">make -C &#39;..&#x2F;..&#x2F;..&#39; DESTDIR&#x3D;&#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#39;&#x2F;tmp_install install &gt;&#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#39;&#x2F;tmp_install&#x2F;log&#x2F;install.log 2&gt;&amp;1</span><br><span class="line">make -j1  checkprep &gt;&gt;&#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#39;&#x2F;tmp_install&#x2F;log&#x2F;install.log 2&gt;&amp;1</span><br><span class="line">rm -rf &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#39;&#x2F;tmp_check</span><br><span class="line">&#x2F;bin&#x2F;mkdir -p &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#39;&#x2F;tmp_check</span><br><span class="line">cd . &amp;&amp; TESTDIR&#x3D;&#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#39; PATH&#x3D;&quot;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;tmp_install&#x2F;home&#x2F;sandbox&#x2F;pgapp&#x2F;bin:$PATH&quot; LD_LIBRARY_PATH&#x3D;&quot;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;tmp_install&#x2F;home&#x2F;sandbox&#x2F;pgapp&#x2F;lib:$LD_LIBRARY_PATH&quot;  PGPORT&#x3D;&#39;65432&#39; PG_REGRESS&#x3D;&#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#x2F;..&#x2F;..&#x2F;..&#x2F;src&#x2F;test&#x2F;regress&#x2F;pg_regress&#39; &#x2F;usr&#x2F;bin&#x2F;prove -I ..&#x2F;..&#x2F;..&#x2F;src&#x2F;test&#x2F;perl&#x2F; -I .  t&#x2F;021_row_visibility.pl t&#x2F;025_stuck_on_old_timeline.pl</span><br><span class="line">t&#x2F;021_row_visibility.pl ......... ok     </span><br><span class="line">t&#x2F;025_stuck_on_old_timeline.pl .. ok   </span><br><span class="line">All tests successful.</span><br><span class="line">Files&#x3D;2, Tests&#x3D;11, 13 wallclock secs ( 0.01 usr  0.00 sys +  1.73 cusr  4.03 csys &#x3D;  5.77 CPU)</span><br><span class="line">Result: PASS</span><br></pre></td></tr></table></figure>

<p>Of course, if you know the makefile very well, you can also do it on your own way. For example, by looking at the output, you can simply do in below steps to achieve the same results.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rm -rf &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#39;&#x2F;tmp_check</span><br><span class="line"></span><br><span class="line">mkdir -p &#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#39;&#x2F;tmp_check</span><br><span class="line"></span><br><span class="line">recovery$ cd . &amp;&amp; TESTDIR&#x3D;&#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#39; PATH&#x3D;&quot;&#x2F;home&#x2F;sandbox&#x2F;pgapp&#x2F;bin:$PATH&quot; PGPORT&#x3D;&#39;65432&#39; top_builddir&#x3D;&#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#x2F;..&#x2F;..&#x2F;..&#39; PG_REGRESS&#x3D;&#39;&#x2F;home&#x2F;sandbox&#x2F;sharedsm&#x2F;src&#x2F;test&#x2F;recovery&#x2F;..&#x2F;..&#x2F;..&#x2F;src&#x2F;test&#x2F;regress&#x2F;pg_regress&#39; &#x2F;usr&#x2F;bin&#x2F;prove -I ..&#x2F;..&#x2F;..&#x2F;src&#x2F;test&#x2F;perl&#x2F; -I .  t&#x2F;021_row_visibility.pl </span><br><span class="line">t&#x2F;021_row_visibility.pl .. ok     </span><br><span class="line">All tests successful.</span><br><span class="line">Files&#x3D;1, Tests&#x3D;10,  5 wallclock secs ( 0.02 usr  0.00 sys +  0.81 cusr  1.42 csys &#x3D;  2.25 CPU)</span><br><span class="line">Result: PASS</span><br></pre></td></tr></table></figure>


<h4 id="4-Summary"><a href="#4-Summary" class="headerlink" title="4. Summary"></a>4. Summary</h4><p>In this blog, I explained how to run a specific test case by using variable <code>PROVE_TESTS</code> for TAP test. You can also run the test manually to skip some tests either take too much time or may failed in the middle and block your test cases. </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="en">
    <link itemprop="mainEntityOfPage" href="https://idrawone.github.io/2021/10/15/what-is-backup-label/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.png">
      <meta itemprop="name" content="David Zhang">
      <meta itemprop="description" content="knowledge is power">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/10/15/what-is-backup-label/" class="post-title-link" itemprop="url">Backup Label in PostgreSQL</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2021-10-15 01:00:00 / Modified: 15:35:50" itemprop="dateCreated datePublished" datetime="2021-10-15T01:00:00-07:00">2021-10-15</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/" itemprop="url" rel="index">
                    <span itemprop="name">PostgreSQL</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/basebackup/" itemprop="url" rel="index">
                    <span itemprop="name">basebackup</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/basebackup/label/" itemprop="url" rel="index">
                    <span itemprop="name">label</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/basebackup/label/start/" itemprop="url" rel="index">
                    <span itemprop="name">start</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/basebackup/label/start/stop/" itemprop="url" rel="index">
                    <span itemprop="name">stop</span>
                  </a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/PostgreSQL/basebackup/label/start/stop/tools/" itemprop="url" rel="index">
                    <span itemprop="name">tools</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="/images/img/fi-backup-label.png" alt="Featured image"></p>
<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>When I was working on some backup and recovery related features for a project based on Postgres, I noticed that there is file called <code>backup_label</code>. By quickly google search, you can find some very nice blogs or books which discussed this topic, such as, <a href="https://www.interdb.jp/pg/pgsql10.html" target="_blank" rel="noopener">The Internals of PostgreSQL</a>, one of my favourite books. In this blog, I am going to talk it a little more based on my experience.</p>
<h4 id="2-What-is-backup-label"><a href="#2-What-is-backup-label" class="headerlink" title="2. What is backup_label?"></a>2. What is backup_label?</h4><p>The <code>backup_label</code> is a file created in $PGDATA folder when there is an <code>exclusive backup</code> triggered by <code>pg_start_backup()</code> and the backup is in progress. This <code>backup_label</code> file will be removed once the <code>pg_stop_backup()</code> is executed. Here, the <code>exclusive backup</code> is one of the backup methods introduced to Postgres early, and as the name indicated, it does not support multiple backup activities at the same time. Because of this limitation, a frontend backup tool <code>pg_basebackup</code> is added to the Postgres later. This <code>pg_basebackup</code> client does allow multiple backup activities performed at the same time. Therefore, this kind of backup is called as <code>non-exclusive backup</code>. Both backup methods use the <code>backup_label</code> but in a different way.</p>
<p>In exclusive basebackup, the <code>backup_label</code> will be generated automatically on the source server side. To see how this file looks like, you can run a command like, <code>select pg_start_backup(&#39;first backup&#39;);</code> from a psql console. Then you should be able to find a <code>backup_label</code> file in $PGDATA folder with the content like below,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">START WAL LOCATION: 0&#x2F;6000028 (file 000000010000000000000006)</span><br><span class="line">CHECKPOINT LOCATION: 0&#x2F;6000060</span><br><span class="line">BACKUP METHOD: pg_start_backup</span><br><span class="line">BACKUP FROM: master</span><br><span class="line">START TIME: 2021-10-15 13:30:03 PDT</span><br><span class="line">LABEL: first backup</span><br><span class="line">START TIMELINE: 1</span><br></pre></td></tr></table></figure>


<h4 id="3-How-does-it-work"><a href="#3-How-does-it-work" class="headerlink" title="3. How does it work?"></a>3. How does it work?</h4><p>In exclusive backup mode, the Postgres source server will generate this file when <code>pg_sart_backup()</code> is executed, and removed after <code>pg_stop_backup()</code>, however, in non-executive backup mode, such as using <code>pg_basebackup</code> client to perform a base backup, the <code>backup_label</code> is only streamed to the client side but not physical saved to the source Postgres server. </p>
<p>As you can see in above <code>baseup_label</code> file, it contains a similar checkpoint information compared to pg_controldata file. If a backup is used in recovery with this backup_label file present, then Postgres will use the checkpoint in backup_label to start the REDO process. The reason is that there could be multiple checkpoints happening during the backup process. After the recovery process is done, this <code>backup_label</code> file will be renamed as <code>backup_label.old</code> to indelicate the recovery finished properly. In simple words, with the <code>backup_label</code> file, the database has a consistent checkpoint to recover from a proper archive.</p>
<h4 id="4-Does-it-impact-any-frontend-tool"><a href="#4-Does-it-impact-any-frontend-tool" class="headerlink" title="4. Does it impact any frontend tool?"></a>4. Does it impact any frontend tool?</h4><p>The answer is <code>yes</code>. Some frontend tools will perform differently if a <code>backup_label</code> file is present. For example, if <code>pg_ctl</code> sees a <code>backup_label</code> file during smart shutdown process, it will wait for it to be removed by providing a waring message to the end user with something like,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: online backup mode is active</span><br><span class="line">Shutdown will not complete until pg_stop_backup() is called</span><br></pre></td></tr></table></figure>
<p>Another example is the frontend tool <code>pg_rewind</code> which creates a <code>backup_label</code> to force a recovery to start from the last common checkpoint. </p>
<h4 id="5-Summary"><a href="#5-Summary" class="headerlink" title="5. Summary"></a>5. Summary</h4><p>In this blog, I explained the <code>backup_label</code> file in Postgres. I believe the end users won’t pay attention to it most of the time, but if you do encounter some issues related with <code>backup_label</code> then I hope this blog can give you some clues.</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="David Zhang"
      src="/images/avatar.png">
  <p class="site-author-name" itemprop="name">David Zhang</p>
  <div class="site-description" itemprop="description">knowledge is power</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">27</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">81</span>
        <span class="site-state-item-name">categories</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David Zhang</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> v4.2.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">Theme – <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.7.0
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
