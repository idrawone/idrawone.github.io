<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>David&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/4dfb0a779aa32370c22ca94ba2397da8</icon>
  <subtitle>knowledge is power</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://idrawone.github.io/"/>
  <updated>2020-07-10T23:26:30.733Z</updated>
  <id>https://idrawone.github.io/</id>
  
  <author>
    <name>David Zhang</name>
    <email>idrawone@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>A simple way to trace a bug</title>
    <link href="https://idrawone.github.io/2020/07/10/A-simple-way-to-trace-a-bug-when-you-donot-have-enough-time/"/>
    <id>https://idrawone.github.io/2020/07/10/A-simple-way-to-trace-a-bug-when-you-donot-have-enough-time/</id>
    <published>2020-07-10T08:00:00.000Z</published>
    <updated>2020-07-10T23:26:30.733Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/img/win-fi.png" alt="Featured image"></p><h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>when I was trying to understand PG source code a little bit in deep, I always want to find some tools or skills to help. The reason is that, sometimes, I really don’t want to read the code line by line for a particular topic, but I have to figure out something quickly, or simply say, I am kind of “lazy” at that movement. I found one very simple and easy way to help me when I was studying the geo Geometric Types in PostgreSQL. This simple method helped me find out a bug build in 1997, Thanks to Tom Lane’s help to fix it and committed it to Postgresql. The commit is “35d1eefb29d03d5a85f71038679f1f8a14358255”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   Fix circle_in to accept &quot;(x,y),r&quot; as it&#39;s advertised to do.</span><br><span class="line">   </span><br><span class="line">   Our documentation describes four allowed input syntaxes for circles,</span><br><span class="line">   but the regression tests tried only three ... with predictable</span><br><span class="line">   consequences.  Remarkably, this has been wrong since the circle</span><br><span class="line">datatype was added in 1997, but nobody noticed till now.</span><br></pre></td></tr></table></figure><p>In this blog, I will use this story to explain how did I figure out this bug using a script in a very simple way.</p><h4 id="2-Environment-setup"><a href="#2-Environment-setup" class="headerlink" title="2. Environment setup"></a>2. Environment setup</h4><p>A few months ago, I was trying to see what was all the Geometric Types PostgreSQL can support by checking the official <a href="https://www.postgresql.org/docs/current/datatype-geometric.html" target="_blank" rel="noopener">document</a>. In the section 8.8.7. Circles, there is something describe the different ways to insert a circle. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Circles are represented by a center point and radius. Values of type circle are specified using any of the following syntaxes:</span><br><span class="line"></span><br><span class="line">&lt; ( x , y ) , r &gt;</span><br><span class="line">( ( x , y ) , r )</span><br><span class="line">  ( x , y ) , r</span><br><span class="line">    x , y   , r</span><br></pre></td></tr></table></figure><p>I was so suprised that there are some many ways to draw a circle in PostgreSQL, and accidently I had a psql console connected to a server at that moment. So, I decided to try all the data types one by one. However, when I followed the 3rd way to insert a circle, I encountered some errors like below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tbl_circle(id serial PRIMARY KEY, a circle);</span><br><span class="line">INSERT INTO tbl_circle(a) VALUES(&#39;( 1 , 1 ) , 5&#39;::circle );</span><br><span class="line"></span><br><span class="line">ERROR:  invalid input syntax for type circle: &quot;( 1 , 1 ) , 5&quot;</span><br><span class="line">LINE 1: INSERT INTO tbl_circle(a) VALUES(&#39;( 1 , 1 ) , 5&#39;::circle );</span><br></pre></td></tr></table></figure><p>The first thoughts came to my mind was that I must typed something wrong, but after carefully check each character, I couldn’t find any error. I conldn’t believe what I saw on the screen, therefore I called my colleague to help me do a quick check, but the result was the same. Then I started to think if I can go a little further to find out the bug before report the community it would help a lot. But, the question is how to find the issue out within limited time (I did have a lot of work need to be done at the same moment, in a simple word, “busy”. Well, “busy” is one of the main reasons I want to discuss about this simple method).</p><p>Obviously, I was not familiar with the data type related circle in PostgreSQL source code, but I do know how to compile from source code and how to use gdb to run a simple debug (keep in mind, these are the prerequisite). </p><p>I started to compile the source code with gdb enabled, like below.<br><code>./configure --enable-cassert --enable-debug CFLAGS=&quot;-ggdb -O0 -g3 -fno-omit-frame-pointer”</code></p><p>After the PostgerSQL server restarted, I used gdb to attach to the running background postgres which connected to my psql console. I set up a breakpoint to the function exec_simple_query (well, this is another prerequisite). I tried to repeat the circle insert command, and the gdb stop at exec_simple_query. Now, I was totally stuck. I didn’t how to locate the bug, I had no idea what was behind the circle data type, and in which file it was implemented. How could I move move to the next step?</p><p>I did have one thing in my mind that was I need to quickly find out the difference between the working data type and the non-working data type. To achieve this, a simple way would just enter “next” and then press “enter”. I started to do it, but after repeated 3 times, I totally gave it up. I didn’t know how many times I have to repeat the process and it was not possible for me to capture the difference. Then I started to question myself whether there was a way to automatically type “next” and then “enter” until the circle insert was finished. By a simply google, I found <a href="https://stackoverflow.com/questions/5812411/gdb-automatic-nexting" target="_blank" rel="noopener">this</a>. I copied and pasted the script and added the breakpoint. The scpript was ended up like below,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># file: step_mult.gdb</span><br><span class="line"></span><br><span class="line">set pagination off</span><br><span class="line">set logging file gdb.log</span><br><span class="line">set logging on</span><br><span class="line">break exec_simple_query</span><br><span class="line"></span><br><span class="line">define step_mult</span><br><span class="line">    set $step_mult_max &#x3D; 1000</span><br><span class="line">    if $argc &gt;&#x3D; 1</span><br><span class="line">        set $step_mult_max &#x3D; $arg0</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    set $step_mult_count &#x3D; 0</span><br><span class="line">    while ($step_mult_count &lt; $step_mult_max)</span><br><span class="line">        set $step_mult_count &#x3D; $step_mult_count + 1</span><br><span class="line">        printf &quot;step #%d\n&quot;, $step_mult_count</span><br><span class="line">        step</span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>I re-attach the postgres, ran the command <code>source step_mult.gdb</code> within gdb, and then let the postgres continue to run in the background. I switched to another console and started toinsert a circle using the 3rd way again. Postgres stopped at <code>exec_simple_query</code>, then I ran <code>step_mult 10000</code>. After a while, I saw the error message on my psql console again. I changed the log file gdb.log to gdb-2nd.log and repeated the steps to insert a circle using the 2nd way. Now, I got two gdb log files which contain all the single step for the working and non-working circle data types. </p><p>I used a GUI compare tools to open these two gdb log files. The big difference I saw was showing below (screenshot).<br>Now, I finally figured out where the data type circle was implemented. To proof that it was the right place to fix this issue, I made a quick dirty fix. Then I performed a test and found the 3rd data type was kind of “fixed”. </p><p>At this point, I was more confident to report this issue to the community with my dirty patch to proof that PostgreSQL doesn’t work with the 3rd way. The entire process only took me about an hour (find a bug which has been stayed in PostgreSQL about 23 years in an hour is not so bad). </p><h4 id="3-Summary"><a href="#3-Summary" class="headerlink" title="3.    Summary"></a>3.    Summary</h4><p>PostgreSQL is one of the best open source RDBMS in the world, and there are many other open source projects like it. As a software engineer, we are all either working on them or use them in the daily work, if you find something fishy but don’t have enough time, then try the way I did. It may surprise you. From my opinion, this method may suitable for below sisutations:</p><p>1) one feature is working on your use case but it works on a very similar use case; such as circle<br>2) you want to see the difference in different conditions, such as inset into using memory page<br>3) you want to compare two behaviors in deep from source code point of view;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/img/win-fi.png&quot; alt=&quot;Featured image&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overvi
      
    
    </summary>
    
    
      <category term="PostgreSQL" scheme="https://idrawone.github.io/categories/PostgreSQL/"/>
    
      <category term="Debug" scheme="https://idrawone.github.io/categories/PostgreSQL/Debug/"/>
    
    
  </entry>
  
  <entry>
    <title>Build PostgreSQL and Extension on Windows</title>
    <link href="https://idrawone.github.io/2020/05/15/Build-PostgreSQL-and-Extension-on-Windows/"/>
    <id>https://idrawone.github.io/2020/05/15/Build-PostgreSQL-and-Extension-on-Windows/</id>
    <published>2020-05-15T08:00:00.000Z</published>
    <updated>2020-05-15T22:30:10.898Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/img/win-fi.png" alt="Featured image"></p><h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>PostgreSQL is an open-source RDMS and running across many platforms including Linux (all recent distributions), Windows, FreeBSD, OpenBSD, NetBSD, Mac OS X, AIX, HP/UX, IRIX, Solaris, Tru64 Unix, and UnixWare. There are many discussions about how to build Postgres and extensions from source code on a Linux-like environment, but sometimes, a developer may want to quickly setup a Windows environment to check a feature for cross-platform support. This blog is going to explain how to build Postgres and extensions from source code on Windows platforms and it was tested on Windows 7, 10 and 2019 Server.</p><h4 id="2-Environment-setup"><a href="#2-Environment-setup" class="headerlink" title="2. Environment setup"></a>2. Environment setup</h4><p>This blog refers to the official <a href="https://www.postgresql.org/docs/12/install-windows-full.html" target="_blank" rel="noopener">document</a> and the blog <a href="https://www.2ndquadrant.com/en/blog/compiling-postgresql-extensions-visual-studio-windows" target="_blank" rel="noopener">Compiling PostgreSQL extensions with Visual Studio on Windows</a>, but providing many detailed screenshots on the latest version Visual Studio 2019 for building an extension as a standlone VS2019 project.</p><h5 id="3-Install-VS2019-Windows-SDK-and-other-tools"><a href="#3-Install-VS2019-Windows-SDK-and-other-tools" class="headerlink" title="3. Install VS2019, Windows SDK and other tools"></a>3. Install VS2019, Windows SDK and other tools</h5><p>Download the latest <a href="https://visualstudio.microsoft.com/downloads/?utm_medium=post-banner&utm_source=microsoft.com&utm_campaign=channel+banner&utm_content=launch+vs2019" target="_blank" rel="noopener">Visual Studio 2019</a> package. During the installation process, selecting the option <code>Desktop development with C++</code> is enough to build Postgres. This option will install <code>MSVC for VS 2019</code>, <code>Windows 10 SDK</code> and some basic <code>C/C++ building tools</code>. As described in the official document, <a href="https://platform.activestate.com/activestate/activeperl-5.28/auto-fork?utm_source=activestate.com&utm_medium=referral&utm_content=activeperl-5.28-mac&utm_campaign=user-acquisition" target="_blank" rel="noopener">ActiveState Perl</a> is required to run the build and generate scripts, and <a href="https://platform.activestate.com/activestate/activetcl-8.6/auto-fork?utm_source=activestate.com&utm_medium=referral&utm_content=activetcl-8.6&utm_campaign=user-acquisition" target="_blank" rel="noopener">ActiveState TCL</a> is required for building PL/Tcl. If the you build from a released source code <a href="https://www.postgresql.org/ftp/source/v12.3/" target="_blank" rel="noopener">tar file</a>, then install above tools should be enough for the default configuration, however if you build with the source coded cloned from <a href="https://github.com/postgres/postgres.git" target="_blank" rel="noopener">github</a>, then you need to install <code>Bison</code> and <code>Flex</code>, which can be found <a href="http://www.mingw.org/wiki/MSYS" target="_blank" rel="noopener">here</a>.<br>If you prefer to use Linux style commands as much as possible, then you can install <a href="https://github.com/git-for-windows/git/releases/latest" target="_blank" rel="noopener">git bash</a>. After all the tools has been installed, you need to <code>edit the system environment variables</code> to include all the binaries paths, for example, <img src="/images/img/win-env.png" alt="windows environment image"></p><h5 id="4-Build-postgres"><a href="#4-Build-postgres" class="headerlink" title="4. Build postgres"></a>4. Build postgres</h5><p>If you have an extension need to be built under the source code tree, then it is time to clone or copy your extension to <code>contrib</code> folder before starting the build. To build Postgres is pretty simple, just turn on VS 2019 terminal i.e. <code>Developer Command Prompt for VS 2019</code> and then navigate to the windows build folder inside the postgres source code, for example, <code>c:\Users\Administrator\Downloads\postgres\src\tools\msvc&gt;</code> and then run <code>build.bat</code>.</p><h5 id="5-Regress-test"><a href="#5-Regress-test" class="headerlink" title="5. Regress test"></a>5. Regress test</h5><p>If the build is succeeded, then you can perform a regress test by running <code>vcregress check</code>. To perform a regress test for the extensions, run the command <code>vcregress contribcheck</code>. If you are developing an extension on Windows and you want to speed up the build, then you can build your extension only by running the build script with the extension name, for example, <code>build.bat wal2mongo</code>. However, you can’t run a regress test for each individual extension. This can be worked around by removing all other extension from <code>contrib</code> folder temporally.</p><h5 id="6-Build-extension-in-an-independent-project-using-VS-2019"><a href="#6-Build-extension-in-an-independent-project-using-VS-2019" class="headerlink" title="6. Build extension in an independent project using VS 2019"></a>6. Build extension in an independent project using VS 2019</h5><p>Sometimes a developer may want to build an extension within VS2019 IDE. This is a little bit tricky and not even recommended to do it in this way but it is possible. The blog mentioned above has a detailed discussion about this topic. Here, we provide a step by step guide to walk you through the whole process on VS 2019.</p><ul><li>Start VS 2019 and <code>Create a new project</code></li><li>Select <code>Empty Project</code> template, which will create a C/C++ for Windows without any starting files.</li><li>Give a name for this extension project, for example <code>wal2mongo</code> (We use <a href="https://github.com/HighgoSoftware/wal2mongo.git" target="_blank" rel="noopener">wal2mongo</a> to demonstrate how to build an extension using VS 2019)</li><li>Right click on the project, select <code>Add</code> then <code>New Item...</code></li><li>Select <code>C++ File (.cpp)</code> template and name the file as <code>wal2mongo.c</code></li><li>Copy the whole content from <a href="https://github.com/HighgoSoftware/wal2mongo/blob/release/wal2mongo.c" target="_blank" rel="noopener">this file</a> to the newly created <code>wal2mongo.c</code> file</li><li>Add <code>PGDLLEXPORT</code> after the keyword <code>extern</code>, otherwise MSVC will not export its symbol.<br>the original file,<br><img src="/images/img/win-before.png" alt="before change image"><br>and how it looks like after the changes.<br><img src="/images/img/win-after.png" alt="after change image"></li><li>Right click the project, select <code>Properties</code> and then change following in order,<br>1 Click on <code>Configuration Properities</code> -&gt; <code>General</code> -&gt; Configuration Type, then select <code>Dynamic Library (.dll)</code><br><img src="/images/img/win-pro-1.png" alt="vs pro-1 image"><br>2 Click on <code>Configuration Prosperities</code> -&gt; <code>C/C++</code> -&gt; <code>General</code>, add the including paths in the order below<br><img src="/images/img/win-pro-2.png" alt="vs pro-2 image"><br>3 Click on <code>Configuration Prosperities</code> -&gt; <code>C/C++</code> -&gt; <code>Code Generation</code> -&gt; <code>Enable C++ Exceptions</code>, select <code>No</code><br><img src="/images/img/win-pro-3.png" alt="vs pro-3 image"><br>4 <code>Configuration Prosperities</code> -&gt; <code>C/C++</code> -&gt; <code>Advanced</code> -&gt; <code>Compile As</code>, select <code>Compile as C Code(/TC)</code><br><img src="/images/img/win-pro-4.png" alt="vs pro-4 image"><br>5 Click on <code>Configuration Prosperities</code> -&gt; <code>Linker</code> -&gt; <code>General</code> -&gt; <code>Additional Library Directories</code>, enter the lib path where your Postgres libraries are installed<br><img src="/images/img/win-pro-5.png" alt="vs pro-5 image"><br>6 Click on <code>Configuration Prosperities</code> -&gt; <code>Linker</code> -&gt; <code>Input</code> -&gt; <code>Additional Dependencies</code>, add <code>postgres.lib</code><br><img src="/images/img/win-pro-6.png" alt="vs pro-6 image"><br>7 Click on <code>Configuration Prosperities</code> -&gt; <code>Linker</code> -&gt; <code>Manifest File</code> -&gt; <code>Generate Manifest</code>, select <code>No (/MANIFEST:NO)</code><br><img src="/images/img/win-pro-7.png" alt="vs pro-7 image"></li><li>Finally, right click on the project and then select build.<br>If everything goes fine, then you should see <code>wal2mongo.dll</code> is created. Copy <code>wal2mongo.dll</code> to the lib folder where the Postgres libraries were installed. Then you should be able to test this extension as normal.</li></ul><h4 id="7-Summary"><a href="#7-Summary" class="headerlink" title="7. Summary"></a>7. Summary</h4><p>In this blog, we discussed how to build postgres and extension on Windows, especially to build an extension within VS2019. </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/img/win-fi.png&quot; alt=&quot;Featured image&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overvi
      
    
    </summary>
    
    
      <category term="PostgreSQL" scheme="https://idrawone.github.io/categories/PostgreSQL/"/>
    
      <category term="Extension" scheme="https://idrawone.github.io/categories/PostgreSQL/Extension/"/>
    
      <category term="Build" scheme="https://idrawone.github.io/categories/PostgreSQL/Extension/Build/"/>
    
      <category term="Windows" scheme="https://idrawone.github.io/categories/PostgreSQL/Extension/Build/Windows/"/>
    
      <category term="VS2019" scheme="https://idrawone.github.io/categories/PostgreSQL/Extension/Build/Windows/VS2019/"/>
    
    
  </entry>
  
  <entry>
    <title>Replicate multiple PostgreSQL servers to a single MongoDB server using logical decoding output plugin</title>
    <link href="https://idrawone.github.io/2020/04/17/Replicate-multiple-PostgreSQL-servers-to-a-single-MongoDB-server-using-logical-decoding-output-plugin/"/>
    <id>https://idrawone.github.io/2020/04/17/Replicate-multiple-PostgreSQL-servers-to-a-single-MongoDB-server-using-logical-decoding-output-plugin/</id>
    <published>2020-04-17T11:00:00.000Z</published>
    <updated>2020-04-17T21:39:05.350Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/img/w2m-docker-fi.png" alt="Featured image"></p><h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>“Postgres, is a free and open-source relational database management system (RDBMS) emphasizing extensibility and SQL compliance.” This is the highlight of PostgreSQL in a sentence from Wikipedia. Yes, the extensibility of PostgreSQL is extremely useful when you have some special requirements. This blog will discuss how to use logical decoding output plugin to replicate multiple PostgreSQL servers to a single MongoDB server and the environment setup using docker compose for a quick Proof of Concept.</p><h4 id="2-Logical-decoding-output-plugin"><a href="#2-Logical-decoding-output-plugin" class="headerlink" title="2. Logical decoding output plugin"></a>2. Logical decoding output plugin</h4><p>Start from version 9.5, PostgreSQL provides a solution to allow users to write their own decoding logic to reformat the output before sending it to the subscriber through a wal sender. This feature is called logical decoding output plugin. With this feature, other applications can get a specific data format from PostgreSQL database easily, and then use their own existing tools or algorithms to continue the data analysis. For example, replicating multiple Postgres servers to a single MongoDB server and then perform the real-time analytics and data visualization in MongoDB. There are many different decoding plugins available at <a href="https://wiki.postgresql.org/wiki/Logical_Decoding_Plugins" target="_blank" rel="noopener">here</a>, however <a href="https://github.com/HighgoSoftware/wal2mongo" target="_blank" rel="noopener"><code>wal2mongo</code></a> is only one can generate a JavaScript format data that can be used by MongoDB directly. You can use it following this blog to practice how data replication can be done from multiple Postgres databases to a MongoDB database using logical decoding output plugin.</p><ul><li>Logical decoding output plugin framework</li></ul><p>The logical decoding output plugin framework has a few predefined callback <a href="https://www.postgresql.org/docs/current/logicaldecoding-output-plugin.html" target="_blank" rel="noopener">interfaces</a>. These callbacks are registered in an initialization function named <code>_PG_output_plugin_init</code>, which will be called when the plugin is loaded as a shared library. After hookup with these interfaces by referring to the example <a href="https://www.postgresql.org/docs/current/test-decoding.html" target="_blank" rel="noopener">test_decoding</a>, the output decoding plugin will get notified about the changes that is happening via various callback interfaces. In these callback interfaces, the one will get noticed each time when an insert, update or delete happens is <code>LogicalDecodeChangeCB</code>. Most of the output formatting related logic should be done in a function which is registered to this interface, such as, map a Postgres data type to a MongoDB native data type.<br>Before writing your own logical decoding plugin, two basic things need to be mentioned here: one is the change callback interface is triggered based on each row, i.e. if you have multiple rows changed in one transaction, then you will get multiple times call back; the other is that the callback is triggered only by the row changes that have been safely saved to WAL files. The changes that were rolled back by the transaction will not trigger the callback.</p><ul><li>wal2mongo decoding plugin</li></ul><p><code>wal2mongo</code> is a logical decoding plugin, it mainly converts the DML operation such as insert, update and delete into a JavaScript format which later can be imported into MongoDB by using <code>mongo</code> client.</p><ul><li>Logical decoding data changes flow<br><img src="/images/img/w2m-flow-chart.png" alt="flow chart image"><br>The diagram above shows the data changes flow. We can use <code>psql</code> client to simulate the Application and perform database operation such as create table, insert records, update records and then delete records. The Postgres server backend will save the database changes to WAL first and then notify the WAL sender. The WAL sender will read the changes from WAL and get the output decoded by <code>wal2mongo</code> and then send the changes to the connected subscriber, i.e <code>pg_recvlogical</code> in this blog. <code>pg_recvlogical</code> will save the output as a JavaScript file, then later it will be imported to MongoDB using <code>mongo</code> client.</li></ul><p>To exercise this, we need to change <code>wal_level</code> to <code>logical</code> and make sure <code>max_wal_senders</code> is at least <code>2</code>, then restart Postgres server after the changes.</p><ul><li>Example of <code>wal2mongo</code> output</li></ul><p><code>wal2mongo</code> is designed to replicate the data changes from Postgres to MongoDB, not like a Postgres standby which need to replicate everything. Therefore, the focus is on the mostly used DML operation such as INSERT, UPDATE and DELETE. The diagram below shows the steps inclduing create a table, insert some records, do some update, and then perform a delete and how the data output looks like. Here, you have to change the table replica identity to full, otherwise, you won’t be able to replicate the UPDATE correctly.<br><img src="/images/img/w2m-sequence-chart.png" alt="seq chart image"></p><h4 id="2-Automatic-the-environment-setup-using-docker-compose"><a href="#2-Automatic-the-environment-setup-using-docker-compose" class="headerlink" title="2. Automatic the environment setup using docker compose"></a>2. Automatic the environment setup using docker compose</h4><p>Setup an environment like the one mentioned above to test a logical output plugin may take some time, especially when a user just wants to give a quickly try. I will introduce an easy way using docker to do the work. A Docker environment can be very useful when you want to practice a new technology which requires a complicated setup, or multiple machines to be available. It also help when you need such an environment from time to time, especially when you need it to be available “immediately” and then discard it after you finished your work.<br>To achieve such an environment with multiple Postgres servers and one MongoDB server, I built two docker images: one is a dedicated postgres with wal2mongo installed, and the other one is a dedicated mongod with the <code>pg_recvlogical</code> tools installed. Here is a cluster environment running on a sinlge physical machine using the files available at <a href="">here</a>.<br><img src="/images/img/w2m-docker-diagram.png" alt="docker image"></p><ul><li>Dockerfile for postgres<br>This Dockerfile is to build a docker image with the latest PostgreSQL 12.2 offical release and the <code>wal2mongo</code> installed.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:centos7</span><br><span class="line">MAINTAINER The CentOS Project &lt;cloud-ops@centos.org&gt;</span><br><span class="line"></span><br><span class="line">RUN yum -y install https:&#x2F;&#x2F;download.postgresql.org&#x2F;pub&#x2F;repos&#x2F;yum&#x2F;reporpms&#x2F;EL-7-x86_64&#x2F;pgdg-redhat-repo-latest.noarch.rpm</span><br><span class="line">RUN yum -y update; yum -y install sudo epel-release yum-utils net-tools which \</span><br><span class="line">postgresql12-server postgresql12 \</span><br><span class="line">git gcc make clang zlib-devel readline-devel postgresql12-devel; yum clean all</span><br><span class="line"></span><br><span class="line">RUN usermod -aG wheel postgres</span><br><span class="line">RUN echo &quot;export PATH&#x3D;&#x2F;usr&#x2F;pgsql-12&#x2F;bin:$PATH&quot; | tee -a &#x2F;var&#x2F;lib&#x2F;pgsql&#x2F;.bashrc</span><br><span class="line">RUN echo &quot;postgres ALL&#x3D;(root) NOPASSWD:ALL&quot; &gt; &#x2F;etc&#x2F;sudoers.d&#x2F;postgres &amp;&amp; chmod 0440 &#x2F;etc&#x2F;sudoers.d&#x2F;postgres</span><br><span class="line"></span><br><span class="line">USER postgres</span><br><span class="line">RUN eval &quot;sudo -E env &quot;PATH&#x3D;$PATH&quot; USE_PGXS&#x3D;1 make CLANG&#x3D;&#x2F;usr&#x2F;bin&#x2F;clang with_llvm&#x3D;no install&quot;</span><br><span class="line"></span><br><span class="line">VOLUME  [&quot;&#x2F;var&#x2F;log&#x2F;pgsql&quot;, &quot;&#x2F;var&#x2F;lib&#x2F;pgsql&quot;]</span><br><span class="line">EXPOSE 5432</span><br><span class="line"></span><br><span class="line">COPY run.sh .</span><br><span class="line">CMD [&quot;&#x2F;run.sh&quot;]</span><br></pre></td></tr></table></figure></li></ul><p>What inside the run.sh script is just a simple postgres start command. The way I used it here is to avoid rebuild the image when you want to start the container in different ways.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;usr&#x2F;pgsql-12&#x2F;bin&#x2F;pg_ctl -D &#x2F;var&#x2F;lib&#x2F;pgsql&#x2F;12&#x2F;data -l &#x2F;var&#x2F;log&#x2F;pgsql&#x2F;logfile start</span><br></pre></td></tr></table></figure><ul><li><p>Dockfile for mongod<br>The dockerfile for mongod has the offical MongoDB 4.25 release and pg_recvlogical 12.2 installed.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FROM centos:centos7</span><br><span class="line">MAINTAINER The CentOS Project &lt;cloud-ops@centos.org&gt;</span><br><span class="line"></span><br><span class="line">COPY mongodb.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;</span><br><span class="line">RUN yum -y install mongodb-org-4.2.5 mongodb-org-server-4.2.5 \</span><br><span class="line">mongodb-org-shell-4.2.5 mongodb-org-mongos-4.2.5 \</span><br><span class="line">mongodb-org-tools-4.2.5 postgresql12-contrib; yum clean all</span><br><span class="line">RUN mkdir -p &#x2F;data&#x2F;db</span><br><span class="line"></span><br><span class="line">RUN usermod -aG wheel mongod</span><br><span class="line">RUN echo &quot;mongod ALL&#x3D;(root) NOPASSWD:ALL&quot; &gt; &#x2F;etc&#x2F;sudoers.d&#x2F;mongod &amp;&amp; \</span><br><span class="line">chmod 0440 &#x2F;etc&#x2F;sudoers.d&#x2F;mongod</span><br><span class="line">RUN echo &quot;export PATH&#x3D;&#x2F;usr&#x2F;pgsql-12&#x2F;bin:$PATH&quot; | tee -a &#x2F;root&#x2F;.bashrc</span><br><span class="line">VOLUME  [&quot;&#x2F;data&#x2F;db&quot;, &quot;&#x2F;var&#x2F;log&#x2F;mongodb&quot;]</span><br><span class="line"></span><br><span class="line">EXPOSE 27017</span><br><span class="line">ENTRYPOINT [&quot;&#x2F;usr&#x2F;bin&#x2F;mongod&quot;, &quot;--bind_ip_all&quot;]</span><br></pre></td></tr></table></figure></li><li><p>Service compose file<br>The service docker compose file is to help setup two Postgres servers and one MongodDB servere, and make sure they are be able to communicate using hostname.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;3.0&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  mongo:</span><br><span class="line">    restart: always</span><br><span class="line">    image: &quot;mongod:4.2.5&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;27017:27017&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;data&#x2F;mgdata:&#x2F;data&#x2F;db</span><br><span class="line">      - .&#x2F;scripts&#x2F;p2m.sh:&#x2F;p2m.sh</span><br><span class="line"></span><br><span class="line">  pg1:</span><br><span class="line">    restart: always</span><br><span class="line">    image: &quot;postgres:12.2&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5432&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;data&#x2F;pg1data:&#x2F;var&#x2F;lib&#x2F;pgsql&#x2F;12&#x2F;data</span><br><span class="line">      - .&#x2F;scripts&#x2F;data_gen.sh:&#x2F;data_gen.sh</span><br><span class="line"></span><br><span class="line">  pg2:</span><br><span class="line">    restart: always</span><br><span class="line">    image: &quot;postgres:12.2&quot;</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5432&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;data&#x2F;pg2data:&#x2F;var&#x2F;lib&#x2F;pgsql&#x2F;12&#x2F;data</span><br><span class="line">      - .&#x2F;scripts&#x2F;data_gen.sh:&#x2F;data_gen.sh</span><br></pre></td></tr></table></figure><p>You can easily extend the Postgres servers by adding more instances to this service docker compose file.</p></li></ul><p>To build the containers, run command <code>docker-compose -f service-compose.yml up -d</code>. After a while, you should see two Postgres servers and one MongoDB server are running like below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                 COMMAND                  CREATED              STATUS              PORTS                      NAMES</span><br><span class="line">935a3d339e71        mongod:4.2.5          &quot;&#x2F;usr&#x2F;bin&#x2F;mongod --b…&quot;   About a minute ago   Up About a minute   0.0.0.0:27017-&gt;27017&#x2F;tcp   pg2mongo_mongo_1</span><br><span class="line">d9497be07ce5        postgres:12.2         &quot;&#x2F;run.sh&quot;                About a minute ago   Up About a minute   0.0.0.0:54322-&gt;5432&#x2F;tcp    pg2mongo_pg2_1</span><br><span class="line">50eb555b5719        postgres:12.2         &quot;&#x2F;run.sh&quot;                About a minute ago   Up 38 seconds       0.0.0.0:54321-&gt;5432&#x2F;tcp    pg2mongo_pg1_1</span><br></pre></td></tr></table></figure><p>To setup the logical replication slot on each postgres server, and connect to each slot using <code>pg_recvlogical</code> then pipe the data changes to <code>mongo</code> client and feed the changes to MongoDB automaticlly, run a command like this <code>docker exec -it pg2mongo_mongo_1 bash /p2m.sh 1 2</code>. Where the <code>p2m.sh</code> is a simple demo script to allow you using <code>pg_recvlogical</code> to create slot, and connect to the slot then dump the message to a internal pipe. Then the <code>mongo</code> client will read the pipe and import the changes to MongoDB. You can check it by log into the mongod container and type a <code>ps -ef</code> to see the running services.</p><ul><li><p>Generate database changes<br>To simulate the data changes, you can use <code>pgbench</code>. There are two ways to do it: one is to log into each postgres instance and type the pgbench command; the other way is to map a local script to all postgres instances, then run the script from your host machine. For example <code>docker exec -it pg2mongo_pg1_1 bash /data_gen.sh</code></p></li><li><p>Verify the data changes<br>To verify the data changes, you can log into the mongod container, and then use the mongo cient to check the data changes imported automatically. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; use mycluster_postgres_w2m_slot2;</span><br><span class="line">switched to db mycluster_postgres_w2m_slot2</span><br><span class="line">&gt; db.pgbench_accounts.count();</span><br><span class="line">10028</span><br></pre></td></tr></table></figure></li><li><p>Modify the output plugin and reinstall it<br>You can log into any postgres server and find out the source code and make some changes, then recompile, install it and run a regression test, etc. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it pg2mongo_pg1_1 bash</span><br><span class="line">bash-4.2$ cd &#x2F;var&#x2F;lib&#x2F;pgsql&#x2F;sources&#x2F;wal2mongo&#x2F;</span><br><span class="line">...</span><br><span class="line">bash-4.2$ USE_PGXS&#x3D;1 make clean CLANG&#x3D;&#x2F;usr&#x2F;bin&#x2F;clang with_llvm&#x3D;no</span><br><span class="line">...</span><br><span class="line">bash-4.2$ USE_PGXS&#x3D;1 make CLANG&#x3D;&#x2F;usr&#x2F;bin&#x2F;clang with_llvm&#x3D;no</span><br><span class="line">...</span><br><span class="line">bash-4.2$ USE_PGXS&#x3D;1 make installcheck-force  CLANG&#x3D;&#x2F;usr&#x2F;bin&#x2F;clang with_llvm&#x3D;no</span><br><span class="line">...</span><br><span class="line">bash-4.2$ sudo -E env &quot;PATH&#x3D;$PATH&quot; USE_PGXS&#x3D;1 make CLANG&#x3D;&#x2F;usr&#x2F;bin&#x2F;clang with_llvm&#x3D;no install</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-logical-decoding-output-plugin-limitations"><a href="#3-logical-decoding-output-plugin-limitations" class="headerlink" title="3. logical decoding output plugin limitations"></a>3. logical decoding output plugin limitations</h4><p>The logical decoding output plugin is pretty useful feature, but still has some limitations. For example,</p><ul><li>Only physical relation tables can trigger logical decoding callback, views and sequences cannot trigger</li><li>The tables must have primary key and replica identity need to be set properly</li><li>Database schemas are not be able to be replicated</li><li>No large objects can be replicated<br>…</li></ul><h4 id="4-Summary"><a href="#4-Summary" class="headerlink" title="4. Summary"></a>4. Summary</h4><p>In this blog, we discussed how to use the logical decoding output plugin to replicate multiple PostgreSQL servers to a single MongoDB server, and provide a docker environment setup to perform a quick Proof Of Concept.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/img/w2m-docker-fi.png&quot; alt=&quot;Featured image&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1.
      
    
    </summary>
    
    
      <category term="PostgreSQL" scheme="https://idrawone.github.io/categories/PostgreSQL/"/>
    
      <category term="Replication" scheme="https://idrawone.github.io/categories/PostgreSQL/Replication/"/>
    
      <category term="Logical" scheme="https://idrawone.github.io/categories/PostgreSQL/Replication/Logical/"/>
    
      <category term="Decoding" scheme="https://idrawone.github.io/categories/PostgreSQL/Replication/Logical/Decoding/"/>
    
      <category term="Plugin" scheme="https://idrawone.github.io/categories/PostgreSQL/Replication/Logical/Decoding/Plugin/"/>
    
      <category term="MongoDB" scheme="https://idrawone.github.io/categories/PostgreSQL/Replication/Logical/Decoding/Plugin/MongoDB/"/>
    
      <category term="Docker" scheme="https://idrawone.github.io/categories/PostgreSQL/Replication/Logical/Decoding/Plugin/MongoDB/Docker/"/>
    
      <category term="Compose" scheme="https://idrawone.github.io/categories/PostgreSQL/Replication/Logical/Decoding/Plugin/MongoDB/Docker/Compose/"/>
    
    
  </entry>
  
  <entry>
    <title>PostgreSQL GSSAPI Authentication with Kerberos part-3: the status of authentication, encryption and user principal</title>
    <link href="https://idrawone.github.io/2020/03/15/PostgreSQL-GSSAPI-Authentication-with-Kerberos-part-3/"/>
    <id>https://idrawone.github.io/2020/03/15/PostgreSQL-GSSAPI-Authentication-with-Kerberos-part-3/</id>
    <published>2020-03-15T11:00:00.000Z</published>
    <updated>2020-03-18T20:24:16.951Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/img/fi-part3.png" alt="Featured image"></p><h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>In previous two blogs, we explained how to setup Kerberos, and how to configure PostgreSQL to support GSSAPI user authentication. This blog will be focusing on how to check GSSAPI authentication, encryption and user principal information when given different connection options.</p><h4 id="2-pg-stat-gssapi-view"><a href="#2-pg-stat-gssapi-view" class="headerlink" title="2. pg_stat_gssapi view"></a>2. pg_stat_gssapi view</h4><p>According to the official <a href="https://www.postgresql.org/docs/current/gssapi-auth.html" target="_blank" rel="noopener">PostgreSQL document</a>, “<em>PostgreSQL supports GSSAPI for use as either an encrypted, authenticated layer, or for authentication only.</em>“ To check the authentication, encryption and user principal, we need to use <code>pg_stat_gssapi</code> view, which is a dynamic statistics views containing one row per backend and showing the information about GSSAPI authentication and encryption used on this connection.</p><p>Before start the test below, make sure the <code>PostgreSQL server</code> and the <code>psql client</code> has the option <code>--with-gssap</code> enabled during build time.</p><h4 id="3-Authentication-and-Encryption-status"><a href="#3-Authentication-and-Encryption-status" class="headerlink" title="3. Authentication and Encryption status"></a>3. Authentication and Encryption status</h4><ul><li><strong>Scenario 1:</strong></li></ul><p>Both authentication and encryption are enabled when the host-based authentication is configured with <code>hostgssenc</code> and <code>gss</code> in <code>pg_hba.conf</code><br>Set below user authentication rule to <code>pg_hba.conf</code> and disable all other rules. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostgssenc  postgres  postgres  192.168.0.102&#x2F;32  gss include_realm&#x3D;0 krb_realm&#x3D;HIGHGO.CA</span><br></pre></td></tr></table></figure><p>Initiate the user <code>postgres</code> credential cache using <code>kinit</code>, and then connect to PostgreSQL server with user <code>postgres</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ psql -d postgres -h pg.highgo.ca -U postgres</span><br><span class="line">psql (12.2)</span><br><span class="line">GSSAPI-encrypted connection</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT pid, gss_authenticated, encrypted, principal from pg_stat_gssapi where pid &#x3D; pg_backend_pid();</span><br><span class="line"> pid  | gss_authenticated | encrypted |     principal      </span><br><span class="line">------+-------------------+-----------+--------------------</span><br><span class="line"> 2274 | t                 | t         | postgres@HIGHGO.CA</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure><p>From the result, we can see this connection is encrypted and the user is authenticated with principal <code>postgres@HIGHGO.CA</code>.</p><ul><li><strong>Scenario 2:</strong></li></ul><p>The encryption will be disabled, but user authentication is still enabled when the host-based authentication is configured with <code>hostnogssenc</code> and <code>gss</code> in <code>pg_hba.conf</code><br>Set below user authentication rule to <code>pg_hba.conf</code> and disable all other rules. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostnogssenc  postgres  postgres  192.168.0.102&#x2F;32  gss include_realm&#x3D;0 krb_realm&#x3D;HIGHGO.CA</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ psql -d postgres -h pg.highgo.ca -U postgres</span><br><span class="line">psql (12.2)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT pid, gss_authenticated, encrypted, principal from pg_stat_gssapi where pid &#x3D; pg_backend_pid();</span><br><span class="line"> pid  | gss_authenticated | encrypted |     principal      </span><br><span class="line">------+-------------------+-----------+--------------------</span><br><span class="line"> 2291 | t                 | f         | postgres@HIGHGO.CA</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure><p>The result tells no encryption, but user has been authenticated using principal <code>postgres@HIGHGO.CA</code></p><ul><li><strong>Scenario 3:</strong></li></ul><p>Both encryption and authentication are all enabled when the host-based authentication is configured with <code>host</code> and <code>gss</code> in <code>pg_hba.conf</code>.<br>Set below user authentication rule to <code>pg_hba.conf</code> and disable all other rules. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host  postgres  postgres  192.168.0.102&#x2F;32  gss include_realm&#x3D;0 krb_realm&#x3D;HIGHGO.CA</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ psql -d postgres -h pg.highgo.ca -U postgres</span><br><span class="line">psql (12.2)</span><br><span class="line">GSSAPI-encrypted connection</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT pid, gss_authenticated, encrypted, principal from pg_stat_gssapi where pid &#x3D; pg_backend_pid();</span><br><span class="line"> pid  | gss_authenticated | encrypted |     principal      </span><br><span class="line">------+-------------------+-----------+--------------------</span><br><span class="line"> 2309 | t                 | t         | postgres@HIGHGO.CA</span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure><p>This result is the same as the first one, meaning, <code>host</code> is equivalent to <code>hostgssenc</code> when <code>gss</code> is specified.</p><ul><li><strong>Scenario 4:</strong></li></ul><p>The authentication will be disabled, but encryption is still on when the host-based authentication is configured with <code>host</code> and <code>trust</code> in <code>pg_hba.conf</code>.<br>Set below user authentication rule to <code>pg_hba.conf</code> and disable all other rules. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host  postgres  postgres  192.168.0.102&#x2F;32  trust</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ psql -d postgres -h pg.highgo.ca -U postgres</span><br><span class="line">psql (12.2)</span><br><span class="line">GSSAPI-encrypted connection</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT pid, gss_authenticated, encrypted, principal from pg_stat_gssapi where pid &#x3D; pg_backend_pid();</span><br><span class="line"> pid  | gss_authenticated | encrypted | principal </span><br><span class="line">------+-------------------+-----------+-----------</span><br><span class="line"> 2322 | f                 | t         | </span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure><p>This result tells that the encryption will be always on when <code>--with-gssapi</code> is enabled during build time, unless <code>hostnogssenc</code> is specified in the host-based authentication file.</p><ul><li><strong>Scenario 5:</strong></li></ul><p>Both authentication and encryption will be disabled when the host-based authentication is configured with <code>host</code> and <code>trust</code> in <code>pg_hba.conf</code>, and the client <code>psql</code> requests a non-gssenc mode connection, i.e. <code>gssencmode=disable</code>.<br>Set below user authentication rule to <code>pg_hba.conf</code> and disable all other rules. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">host  postgres  postgres  192.168.0.102&#x2F;32  trust</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ psql -h pg.highgo.ca -U postgres -d &quot;dbname&#x3D;postgres gssencmode&#x3D;disable&quot;</span><br><span class="line">psql (12.2)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# SELECT pid, gss_authenticated, encrypted, principal from pg_stat_gssapi where pid &#x3D; pg_backend_pid();</span><br><span class="line"> pid  | gss_authenticated | encrypted | principal </span><br><span class="line">------+-------------------+-----------+-----------</span><br><span class="line"> 2328 | f                 | f         | </span><br><span class="line">(1 row)</span><br><span class="line"></span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure><p>You can also achieve the same result by setting the environment <code>PGGSSENCMODE=disable</code> from the client side. For example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PGGSSENCMODE&#x3D;disable psql -h pg.highgo.ca -U postgres -d postgres</span><br></pre></td></tr></table></figure><h4 id="4-Summary"><a href="#4-Summary" class="headerlink" title="4. Summary"></a>4. Summary</h4><p>In this blog, we discussed how to check authentication, encryption and user principal in 5 different scenarios. As you can see once <code>--with-gssapi</code> is enabled in PostgreSQL, the encryption will always be turned on unless you specify <code>hostnogssenc</code> in the host-based authentication file, or manually disable gssenc mode from a client side. Knowing the difference might help you when working the security related environment setup using GSSAPI.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/img/fi-part3.png&quot; alt=&quot;Featured image&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Over
      
    
    </summary>
    
    
      <category term="Kerberos" scheme="https://idrawone.github.io/categories/Kerberos/"/>
    
      <category term="GSSAPI" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/"/>
    
      <category term="Authentication" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/"/>
    
      <category term="Ubuntu" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/Ubuntu/"/>
    
      <category term="PostgreSQL" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/Ubuntu/PostgreSQL/"/>
    
    
  </entry>
  
  <entry>
    <title>PostgreSQL GSSAPI Authentication with Kerberos part-2: PostgreSQL Configuration</title>
    <link href="https://idrawone.github.io/2020/03/12/PostgreSQL-GSSAPI-Authentication-with-Kerberos-part-2/"/>
    <id>https://idrawone.github.io/2020/03/12/PostgreSQL-GSSAPI-Authentication-with-Kerberos-part-2/</id>
    <published>2020-03-12T11:00:00.000Z</published>
    <updated>2020-03-18T20:24:32.339Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/img/fi-part2.png" alt="Featured image"></p><h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>In previous <a href="https://idrawone.github.io/2020/03/11/PostgreSQL-GSSAPI-Authentication-with-Kerberos-part-1/">blog</a>, we have setup Kerberos, added all required principals and verified each principal. This blog will explain all the necessary configuration, i.e. <code>postgresql.conf</code>, <code>pg_hba.conf</code> and <code>pg_ident.conf</code>, in PostgreSQL for user authentication using GSSAPI with Kerberos.</p><h4 id="2-Build-PostgreSQL-with-GSSAPI"><a href="#2-Build-PostgreSQL-with-GSSAPI" class="headerlink" title="2. Build PostgreSQL with GSSAPI"></a>2. Build PostgreSQL with GSSAPI</h4><p>The official <a href="https://www.postgresql.org/download/linux/ubuntu/" target="_blank" rel="noopener">PostgreSQL release for Ubuntu</a> has GSSAPI enabled for user authentication with Kerberos, however if you want to build it from source code, you can simply enable it by giving the option <code>--with-gssapi</code> in configure process like below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;configure --with-gssapi --prefix&#x3D;&#x2F;home&#x2F;postgres&#x2F;pgapp</span><br></pre></td></tr></table></figure><p>There is another option <code>--with-krb-srvnam</code>, PostgreSQL uses the default name of the Kerberos service principal. According to Postgres official document, “<em>There’s usually no reason to change this unless you have a Windows environment, in which case it must be set to upper case POSTGRES</em>“. In this blog, we keep it as default, and no extra configuration required for it. After enabled <code>--with-gssapi</code> option, you can build, install, initialize database, change configuration and start database service as normal. The commands used in this blog are list below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">make &amp;&amp; make install</span><br><span class="line">export PATH&#x3D;&#x2F;home&#x2F;postgres&#x2F;pgapp&#x2F;bin:$PATH</span><br><span class="line">export PGDATA&#x3D;&#x2F;home&#x2F;postgres&#x2F;pgdata&#x2F;data </span><br><span class="line">initdb -D $PGDATA</span><br></pre></td></tr></table></figure><h4 id="3-Keytab-file"><a href="#3-Keytab-file" class="headerlink" title="3. Keytab file"></a>3. Keytab file</h4><p>If you have followed the previous blog “part-1: how to setup Kerberos on Ubuntu”, then you should already have the keytab file. Now, copy the keytab file to Service Server (Postgres Server) and put it to a folder with appropriate permissions to the user owning the Postgres process. For example, user <code>postgres</code> and folder <code>/home/postgres/pgdata/data</code> in this blog. The instance principal extracted from KDC server can be verified using ktutil on Service Server. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ ktutil </span><br><span class="line">ktutil:  list</span><br><span class="line">slot KVNO Principal</span><br><span class="line">---- ---- ---------------------------------------------------------------------</span><br><span class="line">ktutil:  read_kt postgres.keytab </span><br><span class="line">ktutil:  list</span><br><span class="line">slot KVNO Principal</span><br><span class="line">---- ---- ---------------------------------------------------------------------</span><br><span class="line">   1    1          postgres&#x2F;pg.highgo.ca@HIGHGO.CA</span><br><span class="line">ktutil:</span><br></pre></td></tr></table></figure><p><code>postgres/pg.highgo.ca@HIGHGO.CA</code> is the principal we defined in previous blog in the format of <code>primary/instance@REALM</code>. In this example, <code>postgres</code> is the service, <code>/pg.highgo.ca</code> is the instance using the hostname.</p><h4 id="4-PostgreSQL-Configuration"><a href="#4-PostgreSQL-Configuration" class="headerlink" title="4. PostgreSQL Configuration"></a>4. PostgreSQL Configuration</h4><p>Once keytab file has been set properly, we can configure the keytab file location in postgresql.conf like below.<br><code>krb_server_keyfile = &#39;/home/postgres/pgdata/data/postgres.keytab&#39;</code>.  </p><p>Other than the keytab, we also need Postgres Server to allow connection from the network by change the listen_addresses.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses &#x3D; &#39;*&#39;</span><br></pre></td></tr></table></figure><p>This is the minimum changes in postgresql.conf required for GSSAPI user authentication with Kerberos. </p><h4 id="5-PostgreSQL-Client-Authentication"><a href="#5-PostgreSQL-Client-Authentication" class="headerlink" title="5. PostgreSQL Client Authentication"></a>5. PostgreSQL Client Authentication</h4><p><code>pg_hba.conf</code> is the file used to control clients authentication in PostgreSQL, where <code>hba</code> stands for host-based authentication. A default <code>pg_hba.conf</code> file is installed when the data directory is initialized by initdb. For details please refer to the <a href="(https://www.postgresql.org/docs/current/view-pg-hba-file-rules.html">rules</a> defined for this file, which provides a summary of the contents of the client authentication configuration file. The basic rule is that “<em>The first record with a matching connection type, client address, requested database, and user name is used to perform authentication. There is no <code>fall-through</code> or <code>backup</code>: if one record is chosen and the authentication fails, subsequent records are not considered. If no record matches, access is denied</em>.” In this blog, we will be focusing on GSSAPI releated users authentication using two key words, i.e. <code>hostgssenc</code> and <code>hostnogssenc</code> for the tests. For now, just put below two lines started with <code>hostgssenc</code> after IPv4 local connections.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># IPv4 local connections:</span><br><span class="line">host    all             all             127.0.0.1&#x2F;32            trust </span><br><span class="line">hostgssenc postgres     david           192.168.0.0&#x2F;24          gss include_realm&#x3D;0</span><br><span class="line">hostgssenc postgres     postgres        192.168.0.0&#x2F;24          gss include_realm&#x3D;0</span><br></pre></td></tr></table></figure><p>Here is how we define the user authentication for using GSSAPI according to <a href="https://www.postgresql.org/docs/current/auth-pg-hba-conf.html" target="_blank" rel="noopener">PostgreSQL document</a>.</p><ul><li><code>hostgssenc</code> is used to match a TCP connection made with GSSAPI encryption.</li><li><code>postgres</code> is the database name. </li><li><code>david</code> and <code>postgres</code> are the users allowed to connect to the database. </li><li><code>192.168.0.0/24</code> is the network for this particular setup.</li><li><code>gss include_realm=0</code> means the authentication method <code>gss</code> is used with the option <code>include_realm=0</code> which indeicates the realm name from the authenticated user principal will be stripped off before being passed through the user name mapping.</li></ul><h4 id="6-PostgreSQL-User-Name-Maps"><a href="#6-PostgreSQL-User-Name-Maps" class="headerlink" title="6. PostgreSQL User Name Maps"></a>6. PostgreSQL User Name Maps</h4><p><a href="https://www.postgresql.org/docs/current/auth-username-maps.html" target="_blank" rel="noopener">pg_indent.conf</a> is used to map the users. The mapping can be used when user want to use email like user name e.g. <code>postgres@highgo.ca</code> to log in the database. For example, <code>postgres@highgo.ca</code> could be mapped to just <code>postgres</code>. According to <a href="https://www.postgresql.org/docs/current/auth-pg-hba-conf.html" target="_blank" rel="noopener">PostgreSQL document</a>, if <code>hostgssenc</code> is used, then only three authentication options are allowed: <code>gss</code>, <code>reject</code>, and <code>trust</code>. When <code>gss</code> is selected as the authentication option, then you can use below three option to specify the <code>gss</code> in further details.</p><ul><li><strong>include_realm:</strong> default set to <code>1</code>, if <code>0</code> is specified as above example, then realm name from the authenticated user principal is stripped off.</li><li><strong>map:</strong> is the mapping between system and database user names. The mapping supports regular expression when system user started with <code>/</code>. For example, <code>mymap   /^(.*)@mydomain\.com$      \1</code> is to remove the domain part for users from system user names. </li><li><strong>krb_realm:</strong> is used to match user principal names. If this parameter is set, only users of that realm will be accepted.<br>For example,<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostgssenc  postgres  postgres  192.168.0.0&#x2F;24  gss include_realm&#x3D;1 map&#x3D;mymap krb_realm&#x3D;HIGHGO.CA</span><br></pre></td></tr></table></figure>Where, <code>gss include_realm=1 map=mymap krb_realm=HIGHGO.CA</code> is saying, match a TCP connection with GSS encryption enabled and map system user using <code>mymap</code> defined in <code>pg_ident.conf</code> for user from reamlm <code>HIGHGO.CA</code> only.</li></ul><h4 id="7-User-Authentication"><a href="#7-User-Authentication" class="headerlink" title="7. User Authentication"></a>7. User Authentication</h4><p>Now, we have one database admin user <code>postgres</code> setup on PostgreSQL server, let’s restrict this <code>postgres</code> user has to connect to Postgre server using GSSAPI user authentication with Kerberos.</p><h5 id="7-1-database-admin-user-local-authentication"><a href="#7-1-database-admin-user-local-authentication" class="headerlink" title="7.1. database admin user local authentication"></a>7.1. database admin user local authentication</h5><p>Disable all other user authentication <code>in pg_hba.conf</code>, set user authentication to allow <code>gss</code> with <code>include_realm=0</code> only, then restart Postgres server. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hostgssenc  postgres  postgres  192.168.0.0&#x2F;24  gss include_realm&#x3D;0</span><br></pre></td></tr></table></figure><p>From Postgres server terminal, run <code>kdestroy -A</code> to clean all cached credentials, then run <code>klist</code> to check.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ klist</span><br><span class="line">klist: No credentials cache found (filename: &#x2F;tmp&#x2F;krb5cc_1001)</span><br></pre></td></tr></table></figure><p>No credentials cached yet, then run <code>kinit postgres</code> to initial the user authentication.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kinit postgres</span><br><span class="line">Password for postgres@HIGHGO.CA:</span><br></pre></td></tr></table></figure><p>Now, check the cached credentials again,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ klist</span><br><span class="line">Ticket cache: FILE:&#x2F;tmp&#x2F;krb5cc_1001</span><br><span class="line">Default principal: postgres@HIGHGO.CA</span><br><span class="line"></span><br><span class="line">Valid starting       Expires              Service principal</span><br><span class="line">2020-03-15 14:17:07  2020-03-16 00:17:07  krbtgt&#x2F;HIGHGO.CA@HIGHGO.CA</span><br><span class="line">renew until 2020-03-16 14:17:04</span><br></pre></td></tr></table></figure><p>After the credentials has been cached, let’s try to log in use database admin user <code>postgres</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ psql -d postgres -h pg.highgo.ca -U postgres</span><br><span class="line">psql (12.2)</span><br><span class="line">GSSAPI-encrypted connection</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# \q</span><br></pre></td></tr></table></figure><p>As the message <code>GSSAPI-encrypted connection</code> above indicates the connection is encrypted. Let’s check the cached credentials again,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ klist</span><br><span class="line">Ticket cache: FILE:&#x2F;tmp&#x2F;krb5cc_1001</span><br><span class="line">Default principal: postgres@HIGHGO.CA</span><br><span class="line"></span><br><span class="line">Valid starting       Expires              Service principal</span><br><span class="line">2020-03-15 14:17:07  2020-03-16 00:17:07  krbtgt&#x2F;HIGHGO.CA@HIGHGO.CA</span><br><span class="line">renew until 2020-03-16 14:17:04</span><br><span class="line">2020-03-15 14:21:21  2020-03-16 00:17:07  postgres&#x2F;pg.highgo.ca@</span><br><span class="line">renew until 2020-03-16 14:17:04</span><br><span class="line">2020-03-15 14:21:21  2020-03-16 00:17:07  postgres&#x2F;pg.highgo.ca@HIGHGO.CA</span><br><span class="line">renew until 2020-03-16 14:17:04</span><br></pre></td></tr></table></figure><p>We can see the credentials for service principal <code>postgres/pg.highgo.ca</code> has been cached.<br><img src="/images/img/gssapi-postgres.png" alt="GSSAPI Postgres"><br>From the above wireshark capture, </p><ul><li>message 1: AS_REQ is the initial user authentication request triggered by <code>kinit</code>.</li><li>message 2: KRB Error is the reply from Authentication Server to ask password for user <code>postgres</code></li><li>message 3: AS_REQ is the user authentication request encrypted using <code>postgres</code>‘s password</li><li>message 4: AS_REP is the encrypted reply from Authentication Server. Upon now, <code>kini</code> is done, and user <code>postgres</code>‘s credential has been cached.</li><li>message 5: TGS_REQ is the request from <code>psql</code> to Ticket Granting Server (TGS) for a service ticket.</li><li>message 6: TGS_REP is the reply from Ticket Granting Server which contains a service session key generated by TGS and encrypted using a temporary session key generated by AS for user <code>postgres</code>.</li></ul><p>Within the service principal expire time, any new log in from the same machine with user <code>postgres</code> will not be required to provide the password. If you use wireshark to monitor the traffic again, you won’t see any <code>KRB5</code> message between KDC and Postgres Server.</p><h5 id="7-2-database-admin-user-remote-authentication"><a href="#7-2-database-admin-user-remote-authentication" class="headerlink" title="7.2. database admin user remote authentication"></a>7.2. database admin user remote authentication</h5><p>Now, let’s run the same test from the Client machine to observer the authentication messages.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ kdestroy -A</span><br><span class="line">$ klist</span><br><span class="line">klist: No credentials cache found (filename: &#x2F;tmp&#x2F;krb5cc_1000)</span><br><span class="line"></span><br><span class="line">$ klist</span><br><span class="line">Ticket cache: FILE:&#x2F;tmp&#x2F;krb5cc_1000</span><br><span class="line">Default principal: postgres@HIGHGO.CA</span><br><span class="line"></span><br><span class="line">Valid starting       Expires              Service principal</span><br><span class="line">2020-03-15 14:57:53  2020-03-16 00:57:53  krbtgt&#x2F;HIGHGO.CA@HIGHGO.CA</span><br><span class="line">renew until 2020-03-16 14:57:50</span><br><span class="line"></span><br><span class="line">$ psql -d postgres -U postgres -h pg.highgo.ca</span><br><span class="line">psql (12.2)</span><br><span class="line">GSSAPI-encrypted connection</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres&#x3D;# \q</span><br><span class="line"></span><br><span class="line">$ klist</span><br><span class="line">Ticket cache: FILE:&#x2F;tmp&#x2F;krb5cc_1000</span><br><span class="line">Default principal: postgres@HIGHGO.CA</span><br><span class="line"></span><br><span class="line">Valid starting       Expires              Service principal</span><br><span class="line">2020-03-15 14:57:53  2020-03-16 00:57:53  krbtgt&#x2F;HIGHGO.CA@HIGHGO.CA</span><br><span class="line">renew until 2020-03-16 14:57:50</span><br><span class="line">2020-03-15 14:58:00  2020-03-16 00:57:53  postgres&#x2F;pg.highgo.ca@</span><br><span class="line">renew until 2020-03-16 14:57:50</span><br><span class="line">2020-03-15 14:58:00  2020-03-16 00:57:53  postgres&#x2F;pg.highgo.ca@HIGHGO.CA</span><br><span class="line">renew until 2020-03-16 14:57:50</span><br></pre></td></tr></table></figure><p><img src="/images/img/gssapi-postgres-client.png" alt="GSSAPI Client"><br>The result is almost the same as authenticate user <code>postgres</code> on PostgreSQL server, but if you look at the wireshark, you will find the PostgreSQL Server, i.e. <code>192.168.0.102</code> didn’t involve in the entire user authentication process. In other words, PostgreSQL Server only rely on the keytab file extracted from KDC server.</p><p>If you want to use a different user to log into database, then you need create the user on PostgreSQL server as database user, and create the principal for this user on KDC server. Create corresponding user authentication in <code>pg_hba.conf</code> file and restart PostgreSQL server. Then you should be able to use the new user to log in database from either Client machine or PostgreSQL server machine.</p><h4 id="8-Common-errors"><a href="#8-Common-errors" class="headerlink" title="8. Common errors"></a>8. Common errors</h4><p>Some common errors may happen during the PostgreSQL user authentication with Kerberos. Here is a short list.</p><ul><li><p>Try to connect before the user credentials has been cached</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ psql -d postgres -h pg.highgo.ca -U postgres</span><br><span class="line">psql: error: could not connect to server: FATAL:  no pg_hba.conf entry for host &quot;192.168.0.103&quot;, user &quot;postgres&quot;, database &quot;postgres&quot;</span><br></pre></td></tr></table></figure></li><li><p>User doesn’t exist in KDC</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ psql -d postgres -h pg.highgo.ca -U jack</span><br><span class="line">psql: error: could not connect to server: FATAL:  no pg_hba.conf entry for host &quot;192.168.0.103&quot;, user &quot;jack&quot;, database &quot;postgres&quot;</span><br></pre></td></tr></table></figure></li><li><p>Service principal is expired</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ psql -d postgres -h pg.highgo.ca -U postgres</span><br><span class="line">psql: error: could not connect to server: could not initiate GSSAPI security context: Unspecified GSS failure.  Minor code may provide more information</span><br><span class="line">could not initiate GSSAPI security context: Ticket expired</span><br><span class="line">FATAL:  no pg_hba.conf entry for host &quot;192.168.0.103&quot;, user &quot;postgres&quot;, database &quot;postgres&quot;</span><br></pre></td></tr></table></figure><h4 id="9-Summary"><a href="#9-Summary" class="headerlink" title="9. Summary"></a>9. Summary</h4><p>In this blog, we explained how to enable GSSAPI from source code and the keytab file, discussed those three key configuration files, i.e. “PostgreSQL Configuration”, “PostgreSQL Client Authentication” and “PostgreSQL Users Mapping”, and we also demonstrated user authentication from different hosts with Kerberos. In next blog, we will discuss how to check authentication and encryption status for different connection requests.</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/img/fi-part2.png&quot; alt=&quot;Featured image&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Over
      
    
    </summary>
    
    
      <category term="Kerberos" scheme="https://idrawone.github.io/categories/Kerberos/"/>
    
      <category term="GSSAPI" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/"/>
    
      <category term="Authentication" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/"/>
    
      <category term="Ubuntu" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/Ubuntu/"/>
    
      <category term="PostgreSQL" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/Ubuntu/PostgreSQL/"/>
    
    
  </entry>
  
  <entry>
    <title>PostgreSQL GSSAPI Authentication with Kerberos part-1: how to setup Kerberos on Ubuntu</title>
    <link href="https://idrawone.github.io/2020/03/11/PostgreSQL-GSSAPI-Authentication-with-Kerberos-part-1/"/>
    <id>https://idrawone.github.io/2020/03/11/PostgreSQL-GSSAPI-Authentication-with-Kerberos-part-1/</id>
    <published>2020-03-11T13:00:00.000Z</published>
    <updated>2020-03-18T01:13:18.244Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/images/img/fi-part1.png" alt="Featured image"></p><h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>PostgreSQL supports many secure ways to authenticate users, and one typical way is to use GSSAPI with Kerberos. However, when I was trying to investigate one issue which is related with GSSAPI in PostgreSQL, I couldn’t find a tutorial that I can follow to setup the environment easily. After some effort spent on Kerberos environment setup, I decided to write a blog to share what I have learned.</p><p>Since PostgreSQL GSSAPI user authentication does involve many background knowledge, I separate this blog into 3 parts: </p><ul><li>part-1 will be focusing on the basic concepts used in Kerberos, Servers/Clients/Services/Users setup, and environment verification;</li><li>part-2 will discuss all related configuration files required on PostgreSQL for using GSSAPI user authentication;</li><li>part-3 will explain how to check GSSAPI authentication, encryption and user principal information for different connection options to have a better understanding about GSSAPI on PostgreSQL.</li></ul><h4 id="2-Basic-Concepts-for-Kerberos"><a href="#2-Basic-Concepts-for-Kerberos" class="headerlink" title="2. Basic Concepts for Kerberos"></a>2. Basic Concepts for Kerberos</h4><p>Kerberos is a network authentication protocol, which is designed to allow users to prove their identities over a non-secure network in a secure manner. This protocol is an industry-standard protocol for secure authentication with the messages designed to against spying and replay attacks. It has been built into a wide range of software such as, Chrome, Firefox, OpenSSH, Putty, OpenLDAP, Thunderbird and PostgreSQL etc. There are some open source implementations available such as, <a href="https://github.com/krb5/krb5.git" target="_blank" rel="noopener">krb5</a> implemented by MIT used by most of the Unix-like Operating Systems, and <a href="https://github.com/heimdal/heimdal" target="_blank" rel="noopener">heimdal</a> used by OSX. Before dive into any detailed environment setup, some key concepts used in Kerberos need to be explained here.</p><p><strong>Realm</strong>: Realm is equivalent to a domain or a group that all the users and servers belong to. It is required during Kerberos installation. For example, <code>HIGHGO.CA</code>, will be used as the Realm in this blog (change it according to your needs).</p><p><strong>Principal</strong>: any users and services are defined as a principal in Kerberos. For example, <code>david</code>, <code>postgres</code>, <code>postgres/pg.highgo.ca</code> etc.</p><p><strong>Instance</strong>: Kerberos uses Instance to manage service principals and especially for administrative principals. For example, <code>root/admin</code> where <code>root</code> is the principal and <code>/admin</code> is the instance.</p><p><strong>SS</strong>: <strong>S</strong>ervice <strong>S</strong>erver provides the services. For example, <code>pg.highgo.ca</code> is a server provide PostgreSQL database access service.</p><p><strong>KDC</strong>: <strong>K</strong>ey <strong>D</strong>istribution <strong>C</strong>enter contains one database of all principals and two components:</p><ul><li><strong>AS</strong>: <strong>A</strong>uthentication <strong>S</strong>erver is responsible for the initial authentication request from users triggered by <code>kinit</code>.</li><li><strong>TGS</strong>: <strong>T</strong>icket <strong>G</strong>ranting <strong>S</strong>erver assigns the requested resource on a Service Server to the users. In this blog, both <strong>AS</strong> and <strong>TGS</strong> are all deployed on the same <strong>KDC</strong> server, i.e. <code>kdc.highgo.ca</code>.</li></ul><p><strong>TGT</strong>: <strong>T</strong>icket <strong>G</strong>ranting <strong>T</strong>icket is a message used to confirm the identity of the principals and to deliver session keys which is used for future secured communication among user, TGS, and SS.</p><p><strong>Keytab</strong>: a file extracted from the KDC principal database and contains the encryption key for a service or host. For example, <code>postgres.keytab</code> is the keytab file and will be used on PostgreSQL server, i.e. <code>hg.highgo.ca</code>.</p><p><strong>Client</strong>: a workstation needs to access a Service Server. For example, <code>psql</code> running on a Client machine and want to connect to PostgreSQL server.</p><h4 id="3-Kerberos-environment-setup"><a href="#3-Kerberos-environment-setup" class="headerlink" title="3. Kerberos environment setup"></a>3. Kerberos environment setup</h4><p><img src="/images/img/gssapi-diagram.png" alt="GSSAPI Diagram"><br>When PostgreSQL authenticates a user with Kerberos, the overall processes in above diagram can be interpreted in below order. </p><ul><li><strong>Client</strong> initiates the authentication process, <strong>AS</strong> sends Client a <em>temporary session key</em> (<em>grey key</em>) encrypted with Client’s key (<em>blue key</em>); </li><li><strong>Client</strong> uses the <em>temporary session key</em> to request services, <strong>TGS</strong> grants the services and sends two copies of the <em>communication session keys</em> (<em>yellow key</em>): one encrypted using <em>temporary session key</em> and another encrypted using Service Server’s key (<em>green key</em>); </li><li><strong>Client</strong> forwards the <em>communication session key</em>  to <strong>Service Server(PG)</strong> to confirm the user authentication. If it succeeded then both Client and Service Server will use the <em>communication session key</em> for the rest of the communication. </li></ul><p>The realm, hostnames, and IP addresses used in this diagram are list below.</p><ul><li><strong>Realm:</strong> HIGHGO.CA</li><li><strong>KDC (AS+TGS):</strong> kdc.highgo.ca (192.168.0.101)</li><li><strong>Service Server (Postgres Server):</strong> pg.highgo.ca (192.168.0.102)</li><li><strong>Client (psql):</strong> client (192.168.0.103)</li></ul><p>In the following sections, we will discuss the setup in details. Here is the list of all the steps.</p><ol><li>setup hostname and IP addresses for each machine</li><li>install Kerberos server packages on KDC server machine</li><li>add admin principal to KDC server</li><li>install Kerberos client packages on Client and Service server machine</li><li>add Service server principal to KDC server</li><li>add Client principal to KDC server</li><li>verify principal on Service server machine</li><li>verify principal on Client machine</li></ol><h5 id="3-1-Hostname-and-IP-addresses"><a href="#3-1-Hostname-and-IP-addresses" class="headerlink" title="3.1. Hostname and IP addresses"></a>3.1. Hostname and IP addresses</h5><p>Because Kerberos protocol has a timestamp involved, all three machines need to have the clock to be synchronized at all the time. This can be done by setup an NTP client pointing some NTP servers in a production environment, but for simple, you can set all three machines in the same time zone with Internet connected. If you don’t have a DNS server ready or if you don’t want to use DNS, then you can manually set up the hostname by performing below commands on a Unix-like machine.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;hostname</span><br></pre></td></tr></table></figure><p>Set <code>kdc</code>, <code>pg</code> and <code>client</code> accordingly to KDC, Service Server and Client machines</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;hosts</span><br></pre></td></tr></table></figure><p>Set below information to <code>/etc/hosts</code> for all three machines (change the hostname and IP addresses to fit your environment). </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">192.168.0.101kdc.highgo.cakdc</span><br><span class="line">192.168.0.102pg.highgo.capg</span><br><span class="line">192.168.0.103client.highgo.caclient</span><br></pre></td></tr></table></figure><p>After the setup for all three machines are done, restart all three machines.</p><h5 id="3-2-KDC-server-installation"><a href="#3-2-KDC-server-installation" class="headerlink" title="3.2. KDC server installation"></a>3.2. KDC server installation</h5><p>To setup Kerberos on KDC machine, two packages, i.e. <code>krb5-kdc</code> and <code>krb5-admin-server</code> need to be installed.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install krb5-kdc krb5-admin-server</span><br></pre></td></tr></table></figure><p>During the installation, the Kerberos will first ask for configuration of the realm. If you have the hosts setup already following about steps, then the realm will automatically show up, then simply click OK.<br><img src="/images/img/gssapi-realm.png" alt="Kerberos Realm"></p><p>Then it will ask to configure the Kerberos server, in our case, enter <code>kdc.highgo.ca</code><br><img src="/images/img/gssapi-kerberos-server.png" alt="Kerberos Server"></p><p>And then ask for the administrative server, in our case, again, <code>kdc.highgo.ca</code><br><img src="/images/img/gssapi-admin-server.png" alt="Kerberos Admin Server"></p><p>In the last step, it will remind you to use <code>krb5_newrealm</code> to setup the realm. Simply click OK.<br><img src="/images/img/gssapi-kerberos-ok.png" alt="Kerberos OK"></p><p>Now, let’s run the <code>krb5_newrealm</code> with sudo to set up the master key for KDC database.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo krb5_newrealm</span><br><span class="line">Enter KDC database master key: </span><br><span class="line">Re-enter KDC database master key to verify:</span><br></pre></td></tr></table></figure><p>Before start the Kerberos configuration, here are some basic kerberos tools need to know.</p><ul><li>kadmin.local: KDC database administration tool used manage principal and policy.</li><li>kinit: used to obtain and cache Kerberos ticket-granting ticket.</li><li>klist: used to list principal and tickets held in a credentials cache, or the keys held in a keytab file.</li><li>ktutil: used to read, write, or edit entries in a keytab.</li><li>…</li></ul><h5 id="3-3-Admin-Principal-setup"><a href="#3-3-Admin-Principal-setup" class="headerlink" title="3.3. Admin Principal setup"></a>3.3. Admin Principal setup</h5><p>Once KDC server has been installed, we need to create an admin user to manage principals, and it is recommended to use a different username. In our case, <code>root/admin</code>. Below are the commands used for the setup.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo kadmin.local</span><br><span class="line">Authenticating as principal root&#x2F;admin@HIGHGO.CA with password.</span><br><span class="line">kadmin.local:  addprinc root&#x2F;admin</span><br><span class="line">WARNING: no policy specified for root&#x2F;admin@HIGHGO.CA; defaulting to no policy</span><br><span class="line">Enter password for principal &quot;root&#x2F;admin@HIGHGO.CA&quot;: </span><br><span class="line">Re-enter password for principal &quot;root&#x2F;admin@HIGHGO.CA&quot;: </span><br><span class="line">Principal &quot;root&#x2F;admin@HIGHGO.CA&quot; created.</span><br><span class="line">kadmin.local:  exit</span><br></pre></td></tr></table></figure><p>You can check the principal <code>root/admin</code> by running <code>listprincs root/admin</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kadmin.local:  listprincs root&#x2F;admin</span><br><span class="line">root&#x2F;admin@HIGHGO.CA</span><br></pre></td></tr></table></figure><p>Next, we need to assign the appropriate access control list to the admin user in the Kerberos configuration file <code>/etc/krb5kdc/kadm5.acl</code> which is used to manage access rights to the Kerberos database.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;krb5kdc&#x2F;kadm5.acl</span><br><span class="line">root&#x2F;admin@HIGHGO.CA    *</span><br></pre></td></tr></table></figure><p>The above configuration gives all privileges to admin principal <code>root/admin</code>.</p><p>Now, finally it is time to restart Kerberos service.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart krb5-admin-server.service</span><br></pre></td></tr></table></figure><p>Once Kerberos service is running again, we can perform a quick test. First, try <code>klist</code> to see if any credentials cache exists, then try to see if <code>root/admin</code> can be authenticated. If no error, then try to use <code>klist</code> again to list the principal cached. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ klist</span><br><span class="line">klist: No credentials cache found (filename: &#x2F;tmp&#x2F;krb5cc_1000)</span><br></pre></td></tr></table></figure><p>The “No credentials cache found” tells us there is no principal has been authenticated yet. Let’s run <code>kinit root/admin</code> to see if we can get it authenticated.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kinit root&#x2F;admin</span><br><span class="line">Password for root&#x2F;admin@HIGHGO.CA:</span><br></pre></td></tr></table></figure><p>If no error during root principal init, then run <code>klist</code> again.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ klist</span><br><span class="line">Ticket cache: FILE:&#x2F;tmp&#x2F;krb5cc_1000</span><br><span class="line">Default principal: root&#x2F;admin@HIGHGO.CA</span><br><span class="line"></span><br><span class="line">Valid starting       Expires              Service principal</span><br><span class="line">2020-03-12 17:18:53  2020-03-13 03:18:53  krbtgt&#x2F;HIGHGO.CA@HIGHGO.CA</span><br><span class="line">renew until 2020-03-13 17:18:51</span><br></pre></td></tr></table></figure><p>If the credentials cache is found, then the KDC administrative principal setup is done.</p><h5 id="3-4-Service-Server-and-Client-installation"><a href="#3-4-Service-Server-and-Client-installation" class="headerlink" title="3.4. Service Server and Client installation"></a>3.4. Service Server and Client installation</h5><p>For Service Server and Client, we only need to install the client/user related packages. Run below commands on both Service Server and Client machines.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install krb5-user libpam-krb5 libpam-ccreds auth-client-config</span><br></pre></td></tr></table></figure><p>Same as KDC Server setup, it will ask for Realm, Kerberos server and Administrative server. Enter exactly the same information used for KDC Server and then click OK. After the installation is done, we should have below information configured in <code>/etc/krb5.conf</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[realms]</span><br><span class="line">HIGHGO.CA &#x3D; &#123;</span><br><span class="line">kdc &#x3D; kdc.highgo.ca</span><br><span class="line">admin_server &#x3D; kdc.highgo.ca</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Now, back to KDC Server side to add principals for Service Server and Client.</p><h5 id="3-5-Add-principal-for-Service-Server"><a href="#3-5-Add-principal-for-Service-Server" class="headerlink" title="3.5. Add principal for Service Server"></a>3.5. Add principal for Service Server</h5><ul><li><p>Add a principal <code>postgres</code> which is the database user and the Linux login user.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ sudo kadmin.local</span><br><span class="line">kadmin.local:  addprinc postgres</span><br><span class="line">WARNING: no policy specified for postgres@HIGHGO.CA; defaulting to no policy</span><br><span class="line">Enter password for principal &quot;postgres@HIGHGO.CA&quot;: </span><br><span class="line">Re-enter password for principal &quot;postgres@HIGHGO.CA&quot;: </span><br><span class="line">Principal &quot;postgres@HIGHGO.CA&quot; created.</span><br></pre></td></tr></table></figure></li><li><p>Add a principal <code>postgres/pg.highgo.ca</code> as a principle instance for Service server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kadmin.local:  addprinc postgres&#x2F;pg.highgo.ca</span><br><span class="line">WARNING: no policy specified for postgres&#x2F;pg.highgo.ca@HIGHGO.CA; defaulting to no policy</span><br><span class="line">Enter password for principal &quot;postgres&#x2F;pg.highgo.ca@HIGHGO.CA&quot;: </span><br><span class="line">Re-enter password for principal &quot;postgres&#x2F;pg.highgo.ca@HIGHGO.CA&quot;: </span><br><span class="line">Principal &quot;postgres&#x2F;pg.highgo.ca@HIGHGO.CA&quot; created.</span><br></pre></td></tr></table></figure></li><li><p>Extract the service principal from KDC principal database to a keytab file, which will be used to configure PostgreSQL Server. The file should be saved to current folder when run below commands.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ktutil </span><br><span class="line">ktutil:  add_entry -password -p postgres&#x2F;pg.highgo.ca@HIGHGO.CA -k 1 -e aes256-cts-hmac-sha1-96</span><br><span class="line">Password for postgres&#x2F;pg.highgo.ca@HIGHGO.CA: </span><br><span class="line">ktutil:  wkt postgres.keytab</span><br><span class="line">ktutil:  exit</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-6-Add-principal-for-Client"><a href="#3-6-Add-principal-for-Client" class="headerlink" title="3.6. Add principal for Client"></a>3.6. Add principal for Client</h5><ul><li>add a principal <code>david</code> for Client, this is the login user for Clinet OS, and later will be used to log into database<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kadmin.local:  addprinc david</span><br><span class="line">WARNING: no policy specified for david@HIGHGO.CA; defaulting to no policy</span><br><span class="line">Enter password for principal &quot;david@HIGHGO.CA&quot;: </span><br><span class="line">Re-enter password for principal &quot;david@HIGHGO.CA&quot;: </span><br><span class="line">Principal &quot;david@HIGHGO.CA&quot; created.</span><br></pre></td></tr></table></figure></li><li>check all the principals using <code>listprincs</code> to confirm <code>david@HIGHGO.CA</code>, <code>postgres@HIGHGO.CA</code> and <code>postgres/pg.highgo.ca@HIGHGO.CA</code> are all successfully created.<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">kadmin.local:  listprincs </span><br><span class="line">K&#x2F;M@HIGHGO.CA</span><br><span class="line">david@HIGHGO.CA</span><br><span class="line">kadmin&#x2F;admin@HIGHGO.CA</span><br><span class="line">kadmin&#x2F;changepw@HIGHGO.CA</span><br><span class="line">kadmin&#x2F;kdc.highgo.ca@HIGHGO.CA</span><br><span class="line">kiprop&#x2F;kdc.highgo.ca@HIGHGO.CA</span><br><span class="line">krbtgt&#x2F;HIGHGO.CA@HIGHGO.CA</span><br><span class="line">postgres&#x2F;pg.highgo.ca@HIGHGO.CA</span><br><span class="line">postgres@HIGHGO.CA</span><br><span class="line">root&#x2F;admin@HIGHGO.CA</span><br></pre></td></tr></table></figure></li></ul><h5 id="3-7-Verify-principal-on-Service-Server"><a href="#3-7-Verify-principal-on-Service-Server" class="headerlink" title="3.7. Verify principal on Service Server"></a>3.7. Verify principal on Service Server</h5><p>After the above principals have been created from KDC Server, let’s back to Service Server to verify the principal using klist and kinit.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ klist</span><br><span class="line">klist: No credentials cache found (filename: &#x2F;tmp&#x2F;krb5cc_1001)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ kinit postgres&#x2F;pg.highgo.ca</span><br><span class="line">Password for postgres&#x2F;pg.highgo.ca@HIGHGO.CA:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres@pg:~$ klist</span><br><span class="line">Ticket cache: FILE:&#x2F;tmp&#x2F;krb5cc_1001</span><br><span class="line">Default principal: postgres&#x2F;pg.highgo.ca@HIGHGO.CA</span><br><span class="line"></span><br><span class="line">Valid starting       Expires              Service principal</span><br><span class="line">2020-03-12 18:25:23  2020-03-13 04:25:23  krbtgt&#x2F;HIGHGO.CA@HIGHGO.CA</span><br><span class="line">renew until 2020-03-13 18:25:20</span><br></pre></td></tr></table></figure><h5 id="3-8-Verify-principal-on-Client"><a href="#3-8-Verify-principal-on-Client" class="headerlink" title="3.8. Verify principal on Client"></a>3.8. Verify principal on Client</h5><p>Now, back to Client machine to verify the principal using klist and kinit.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">david@client:~$ klist</span><br><span class="line">klist: No credentials cache found (filename: &#x2F;tmp&#x2F;krb5cc_1000)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">david@client:~$ kinit david</span><br><span class="line">Password for david@HIGHGO.CA:</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">david@client:~$ klist</span><br><span class="line">Ticket cache: FILE:&#x2F;tmp&#x2F;krb5cc_1000</span><br><span class="line">Default principal: david@HIGHGO.CA</span><br><span class="line"></span><br><span class="line">Valid starting       Expires              Service principal</span><br><span class="line">2020-03-12 18:21:41  2020-03-13 04:21:41  krbtgt&#x2F;HIGHGO.CA@HIGHGO.CA</span><br><span class="line">renew until 2020-03-13 18:21:38</span><br></pre></td></tr></table></figure><p>If the principals verification are all success on both Service Server and Client machines, then we are ready to configure PostgreSQL and prepare GSSAPI user authentication with Kerberos.</p><h4 id="4-Summary"><a href="#4-Summary" class="headerlink" title="4. Summary"></a>4. Summary</h4><p>In this blog, we explained the basic concepts used in Kerberos, performed a step by step setup on Ubuntu, added all the required principals to KDC, and also verified each principal which will be used in next two blogs.</p><p><em><strong>Reference:</strong></em></p><ol><li><a href="https://help.ubuntu.com/lts/serverguide/kerberos.html" target="_blank" rel="noopener">Kerberos on ubuntu</a></li><li><a href="https://simple.wikipedia.org/wiki/Kerberos_(protocol)" target="_blank" rel="noopener">Kerberos wiki</a></li><li><a href="https://www.postgresql.org/docs/current/gssapi-auth.html" target="_blank" rel="noopener">PostgreSQL GSSAPI Authentication</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/images/img/fi-part1.png&quot; alt=&quot;Featured image&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Over
      
    
    </summary>
    
    
      <category term="Kerberos" scheme="https://idrawone.github.io/categories/Kerberos/"/>
    
      <category term="GSSAPI" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/"/>
    
      <category term="Authentication" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/"/>
    
      <category term="Ubuntu" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/Ubuntu/"/>
    
      <category term="PostgreSQL" scheme="https://idrawone.github.io/categories/Kerberos/GSSAPI/Authentication/Ubuntu/PostgreSQL/"/>
    
    
  </entry>
  
  <entry>
    <title>How to create, debug and test an extension written in C for PostgreSQL</title>
    <link href="https://idrawone.github.io/2019/12/31/How-to-create-debug-and-test-an-extension-written-in-C-for-PostgreSQL/"/>
    <id>https://idrawone.github.io/2019/12/31/How-to-create-debug-and-test-an-extension-written-in-C-for-PostgreSQL/</id>
    <published>2019-12-31T08:00:00.000Z</published>
    <updated>2020-01-19T20:54:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>PostgreSQL is one of the most popular free open-source relational database management systems in the world. Other than complies to SQL standard, PostgreSQL also provides a great extensibility which allows users to define their own extensions. With such a great feature, PostgreSQL is not only a database but also an application development platform. In this tutorial, we will go through the entire process about creating an extension, running test against this extension, and debugging the extneson using Eclipse.</p><h4 id="2-Create-an-extension"><a href="#2-Create-an-extension" class="headerlink" title="2. Create an extension"></a>2. Create an extension</h4><p>To create an extension in PostgreSQL, you need at least two files: <code>control</code> file and <code>SQL script</code> file. The <code>control</code> file uses a naming convention <code>extension_name.control</code>. let‘s create an extension call <code>get_sum</code>, then the confile file should contain the basic information like below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ cat get_sum.control </span><br><span class="line"># get_sum postgresql extension</span><br><span class="line">comment &#x3D; &#39;simple sum of two integers for postgres extension using c&#39;</span><br><span class="line">default_version &#x3D; &#39;0.0.1&#39;</span><br><span class="line">module_pathname &#x3D; &#39;$libdir&#x2F;get_sum&#39;</span><br><span class="line">relocatable &#x3D; false</span><br></pre></td></tr></table></figure><ul><li><p><code>comment</code> comments about this extension</p></li><li><p><code>default_version</code> the version of this extension which is also part of the SQL script file</p></li><li><p><code>module_pathname</code> specifies the shared library path for this extension</p></li></ul><p>The <code>SQL script</code> file must be named as <code>extension_name--version.sql</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat get_sum--0.0.1.sql </span><br><span class="line">--complain if script is sourced in psql, rather than via CREATE EXTENSION</span><br><span class="line">\echo Use &quot;CREATE EXTENSION get_sum&quot; to load this file. \quit</span><br><span class="line"> </span><br><span class="line">CREATE OR REPLACE FUNCTION get_sum(int, int) RETURNS int</span><br><span class="line">AS &#39;$libdir&#x2F;get_sum&#39;</span><br><span class="line">LANGUAGE C IMMUTABLE STRICT;</span><br></pre></td></tr></table></figure><p>The second line is to avoid loading this SQL script using <code>psql</code>, and the rest declares the <code>get_sum</code> function will be created in shared library using c language.</p><p>Typically, an extension not only defines new objects, but also adds new logic to deal with those new objects. To boost the performance, you should write the logic in C code with a <code>Makefile</code>.  PostgreSQL provides a build infrastructure for extension called <code>PGXS</code>, which uses a global variable <code>USE_PGXS</code> to include the global <code>PGXS</code> makefiles. One typical <code>Makefile</code> example found in PostgreSQL is something like below. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MODULE_big &#x3D; dblink</span><br><span class="line">… … </span><br><span class="line"></span><br><span class="line">ifdef USE_PGXS</span><br><span class="line">PG_CONFIG &#x3D; pg_config</span><br><span class="line">PGXS :&#x3D; $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br><span class="line">else</span><br><span class="line">SHLIB_PREREQS &#x3D; submake-libpq</span><br><span class="line">subdir &#x3D; contrib&#x2F;dblink</span><br><span class="line">top_builddir &#x3D; ..&#x2F;..</span><br><span class="line">include $(top_builddir)&#x2F;src&#x2F;Makefile.global</span><br><span class="line">include $(top_srcdir)&#x2F;contrib&#x2F;contrib-global.mk</span><br><span class="line">endif</span><br></pre></td></tr></table></figure><p>With <code>PGXS</code> build infrastructure, you can build your extension by simply typing <code>make</code> If you put your extension under the <code>contrib</code> folder within PostgreSQL source tree, or you have to  specify the <code>PG_CONFIG</code> to tell the <code>make</code> command where to find out the <code>pg_config</code> If you put your extension somewhere else.</p><p>In the latest PostgreSQL official document, the assumption that an extension should be under the PostgreSQL source tree has been removed. The reason is that there are more and more extension coming from the Internet, and it is not easy to manage so many extensions within PostgreSQL source tree. Let’s follow the latest instruction to build our <code>Makefile</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ cat Makefile </span><br><span class="line">MODULES &#x3D; get_sum</span><br><span class="line">EXTENSION &#x3D; get_sum # the extersion&#39;s name</span><br><span class="line">DATA &#x3D; get_sum--0.0.1.sql# script file to install</span><br><span class="line">REGRESS &#x3D; get_sum_test  # the test script file</span><br><span class="line"> </span><br><span class="line"># for posgres build</span><br><span class="line">PG_CONFIG &#x3D; pg_config</span><br><span class="line">PGXS :&#x3D; $(shell $(PG_CONFIG) --pgxs)</span><br><span class="line">include $(PGXS)</span><br></pre></td></tr></table></figure><ul><li><p><code>MODUELS</code> specifies the shared object can be used in psql</p></li><li><p><code>EXTENSION</code> specifies the extension name</p></li><li><p><code>DATA</code> specifies the SQL scripts</p></li><li><p><code>REGRESS</code> specifies the regression test script file</p></li></ul><p>The rest is following the latest recommendation from postgreSQL official <a href="https://www.postgresql.org/docs/current/extend-pgxs.html" target="_blank" rel="noopener">website</a>. In other words, we should always provide the <code>PG_CONFIG</code> when building or testing the extension.  </p><p>Once the <code>Makefile</code> is set, you need to create a C file. In this tutorial, we build a simple <code>get_sum</code> function to explain how to add a C file into the extension.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cat get_sum.c</span><br><span class="line">#include &quot;postgres.h&quot;</span><br><span class="line">#include &quot;fmgr.h&quot;</span><br><span class="line"></span><br><span class="line">PG_MODULE_MAGIC;</span><br><span class="line"></span><br><span class="line">PG_FUNCTION_INFO_V1(get_sum);</span><br><span class="line"></span><br><span class="line">Datum</span><br><span class="line">get_sum(PG_FUNCTION_ARGS)</span><br><span class="line">&#123;</span><br><span class="line">    bool isnull, isnull2;</span><br><span class="line"></span><br><span class="line">    isnull &#x3D; PG_ARGISNULL(0);</span><br><span class="line">    isnull2 &#x3D; PG_ARGISNULL(1);</span><br><span class="line">    if (isnull || isnull2)</span><br><span class="line">      ereport( ERROR,</span><br><span class="line">               ( errcode(ERRCODE_FEATURE_NOT_SUPPORTED),</span><br><span class="line">               errmsg(&quot;two and only two integer values are required as input&quot;)));</span><br><span class="line"></span><br><span class="line">    int32 a &#x3D; PG_GETARG_INT32(0);</span><br><span class="line">    int32 b &#x3D; PG_GETARG_INT32(1);</span><br><span class="line">    int32 sum;</span><br><span class="line"></span><br><span class="line">    sum &#x3D; a + b;</span><br><span class="line"></span><br><span class="line">    PG_RETURN_INT32(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Here, the header file <code>postgres.h</code> includes most of the basic stuff needed for interfacing with Postgres. It should be included in every C-File when declares Postgres functions. The header file <code>fmgr.h</code> needs to be included in order to use <code>PG_GETARG_XXX</code>, <code>PG_RETURN_XXX</code> and  <code>PG_ARGISNULL</code> macros. The details about the macros are defined <a href="https://www.postgresql.org/docs/current/xfunc-c.html" target="_blank" rel="noopener">here</a>. This extension function is declared as <code>get_sum</code> with two integers as input parameters, and the result is the sum of these two input parameters.</p><h4 id="3-Test-an-extension"><a href="#3-Test-an-extension" class="headerlink" title="3. Test an extension"></a>3. Test an extension</h4><p>In order to verify this extension, we need to follow PostgreSQL regression test framework to add some test cases. First, we need to create a folder named as <code>sql</code>, which contains the SQL test scripts need to be run.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat sql&#x2F;get_sum_test.sql </span><br><span class="line">CREATE EXTENSION get_sum;</span><br><span class="line">SELECT get_sum(1::INT, 1::INT);</span><br><span class="line">SELECT get_sum(101::INT, 202::INT);</span><br><span class="line">SELECT get_sum(0::INT, 0::INT);</span><br><span class="line">SELECT get_sum(-1::INT, 0::INT);</span><br><span class="line">SELECT get_sum(-1::INT, -1::INT);</span><br><span class="line">SELECT get_sum(-101::INT, -202::INT);</span><br><span class="line">SELECT get_sum(NULL::INT, 11::INT);</span><br><span class="line">SELECT get_sum(-1::INT, NULL::INT);</span><br><span class="line">SELECT get_sum(0::INT, 2147483647::INT);</span><br><span class="line">SELECT get_sum(-2147483648::INT, 0::INT);</span><br><span class="line">SELECT get_sum(2147483647::INT, 2147483647::INT);</span><br><span class="line">SELECT get_sum(-2147483648::INT, -2147483648::INT);</span><br><span class="line">SELECT get_sum(-2147483648::INT, 2147483647::INT);</span><br><span class="line">SELECT get_sum(2147483647::INT, -2147483648::INT);</span><br><span class="line">SELECT get_sum(111111111111111::INT, 222222222222222::INT);</span><br></pre></td></tr></table></figure><p>Then we need to create another folder called <code>expected</code>, as the name indicated, it holds the expected output corresponding to the test SQL script. To build the expected output, as <a href="https://www.postgresql.org/docs/current/extend-pgxs.html" target="_blank" rel="noopener">recommended</a> by postgresSQL: run the test once, a results folder will be generated with the test results named as script_name.out, check the result to see if it is what you expected, then simply copy this result file to <code>expected</code> folder. If you run the test again, the regress test framework will compare a new test results output against the file in <code>expected</code> folder, if any difference found, then a .diff file will be created. Now, let’s run a test.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd crontrib&#x2F;get_sum&#x2F;</span><br><span class="line">make PGUSER&#x3D;postgres PG_CONFIG&#x3D;~&#x2F;eclipse-workspace&#x2F;postgres&#x2F;bin&#x2F;pg_config install</span><br></pre></td></tr></table></figure><p>Build and install the extension including shared library, contorl and SQL script files, then run installcheck to test the extension function using the SQL test scripts.  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make PGUSER&#x3D;postgres PG_CONFIG&#x3D;~&#x2F;eclipse-workspace&#x2F;postgres&#x2F;bin&#x2F;pg_config installcheck</span><br></pre></td></tr></table></figure><p>If the extension function works properly, then you should see the message like below,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;home&#x2F;david&#x2F;eclipse-workspace&#x2F;postgres&#x2F;lib&#x2F;pgxs&#x2F;src&#x2F;makefiles&#x2F;..&#x2F;..&#x2F;src&#x2F;test&#x2F;regress&#x2F;pg_regress --inputdir&#x3D;.&#x2F; --bindir&#x3D;&#39;&#x2F;home&#x2F;david&#x2F;eclipse-workspace&#x2F;postgres&#x2F;bin&#39; --dbname&#x3D;contrib_regression get_sum_test  </span><br><span class="line">(using postmaster on Unix socket, default port)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; dropping database &quot;contrib_regression&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">DROP DATABASE</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; creating database &quot;contrib_regression&quot; &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">CREATE DATABASE</span><br><span class="line">ALTER DATABASE</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; running regression test queries        &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">test get_sum_test                 ... ok           24 ms</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"> All 1 tests passed. </span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h4 id="4-Debug-an-extension"><a href="#4-Debug-an-extension" class="headerlink" title="4. Debug an extension"></a>4. Debug an extension</h4><p>This <code>get_sum</code> is a very simple example to show the basic when creating a new extension from scratch. In reality, the extension will be way complicated, and you might need to keep debugging the extension until it works as designed. If you follow <a href="https://idrawone.github.io/postgresql/eclipse/debug/2019/12/30/How-to-build-PostgreSQL-source-code-using-Eclipse-on-Ubuntu-18.04.html">my previous post</a>, then we can use Eclipse to debug this extension. </p><p>First, turn on a Linux terminal and start the <code>postgers</code> services, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pg_ctl -D $HOME&#x2F;pg12data&#x2F;data&#x2F; -l logfile start</span><br></pre></td></tr></table></figure><p>And then start a <code>psql</code> connection,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ psql -U postgres</span><br><span class="line">psql (12.1)</span><br><span class="line">Type &quot;help&quot; for help.</span><br></pre></td></tr></table></figure><p>Now, create the extension for <code>get_sum</code>,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# CREATE EXTENSION get_sum;</span><br><span class="line">CREATE EXTENSION</span><br></pre></td></tr></table></figure><p>Turn on another terminal, run <code>ps -ef |grep postgres</code> to find out the pid of the <code>postgres</code> which is dealing with requests coming from current <code>psql</code> connection.</p><p>Switch back to the <code>Eclipse</code>, right click on project, select <code>Debug As</code>, then select <code>Debug Configurations…</code>. Fill in the information as shown below then click <code>Debug</code>.</p><p><img src="/images/img/attach-postgres.png" alt="GitHub Logo"></p><p>A window will pop up like below for you to choose the right progres to attach.<br><img src="/images/img/find-postgres-server2.png" alt="GitHub Logo"></p><p>Switch to the <code>psql</code> terminal, then type a query to use this extension, for example,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# select get_sum(111, 222);</span><br></pre></td></tr></table></figure><p>The terminal should be frozen immediately. Switch back to <code>Eclipse</code>, and you should see the <code>postgres</code> stopped inside <code>get_sum</code> c function. If you type <code>bt</code> from the <code>Debugger Console</code>, then the <code>backtrace</code> should show up like below and you can dig into it to see how the extension is eventually called.<br><img src="/images/img/debugger-console-bt2.png" alt="GitHub Logo"></p><p>Now, you can try to print out the input variables and the result before and after, and compare with the <code>psql</code> console input and output. If anything goes wrong, you use Elipse to find out the issue and fix the extension code from there. </p><p>Below is the Eclipse debugging message,<br><img src="/images/img/eclipse-step-in.png" alt="GitHub Logo"></p><p>This is the <code>psql</code> console screenshot,<br><img src="/images/img/psql-console-get-sum.png" alt="GitHub Logo"></p><p>All the source code used in this tutorial is available <a href="https://github.com/idrawone/get_sum.git" target="_blank" rel="noopener">here</a></p><h4 id="5-Summary"><a href="#5-Summary" class="headerlink" title="5. Summary"></a>5. Summary</h4><p>In this blog, we discussed how to create an extension from scratch within <code>PGXS</code> build infrastrature, how to create some test cases to test the extension, and we also covered the procedure of debugging an extension using Eclipse. </p><p><em><strong>Reference:</strong></em></p><p><a href="https://www.highgo.ca/2019/10/01/a-guide-to-create-user-defined-extension-modules-to-postgres/" target="_blank" rel="noopener">1. A Guide to Create User-Defined Extension Modules to Postgres</a></p><p><a href="https://idrawone.github.io/postgresql/eclipse/debug/2019/12/30/How-to-build-PostgreSQL-source-code-using-Eclipse-on-Ubuntu-18.04.html">2. How to build and debug PostgreSQL 12 using latest Eclipse IDE on Ubuntu 18.04</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h4&gt;&lt;p&gt;PostgreSQL is one of the most popula
      
    
    </summary>
    
    
      <category term="Postgres" scheme="https://idrawone.github.io/categories/Postgres/"/>
    
      <category term="Eclipse" scheme="https://idrawone.github.io/categories/Postgres/Eclipse/"/>
    
      <category term="Test" scheme="https://idrawone.github.io/categories/Postgres/Eclipse/Test/"/>
    
      <category term="Debug" scheme="https://idrawone.github.io/categories/Postgres/Eclipse/Test/Debug/"/>
    
      <category term="Extension" scheme="https://idrawone.github.io/categories/Postgres/Eclipse/Test/Debug/Extension/"/>
    
    
  </entry>
  
  <entry>
    <title>How to build and debug PostgreSQL 12 using latest Eclipse IDE on Ubuntu 18.04</title>
    <link href="https://idrawone.github.io/2019/12/30/How-to-build-PostgreSQL-source-code-using-Eclipse-on-Ubuntu-18.04/"/>
    <id>https://idrawone.github.io/2019/12/30/How-to-build-PostgreSQL-source-code-using-Eclipse-on-Ubuntu-18.04/</id>
    <published>2019-12-30T08:50:00.000Z</published>
    <updated>2020-01-19T20:51:24.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Overview"><a href="#1-Overview" class="headerlink" title="1. Overview"></a>1. Overview</h4><p>This tutorial provides detailed instructions to help a newbie setup the building and debugging environment with the latest <code>Eclipse IDE for C/C++ Developers</code> for current <code>Postgres 12.1</code> release on <code>LTS Ubuntu 18.04</code>. Below is the key requirement.</p><ul><li>Linux: ubuntu-18.04.3-desktop-amd64</li><li>Postgres: REL_12_STABLE branch</li><li>Eclipse: eclipse-cpp-2019-12-R-linux-gtk-x86_64.tar.gz</li></ul><h4 id="2-Install-Ubuntu-18-04-Desktop"><a href="#2-Install-Ubuntu-18-04-Desktop" class="headerlink" title="2. Install Ubuntu 18.04 Desktop"></a>2. Install Ubuntu 18.04 Desktop</h4><p>Go to the Ubuntu official <a href="https://ubuntu.com/download/desktop" target="_blank" rel="noopener">website</a> to download the latest LTS Ubuntu 18.04.3 Desktop (64-bit) and Install it on a virtual machine such as VirtualBox. The option “Minimal Installation” with web browser and basic utilities is good enough for this tutorial.</p><h4 id="3-Install-git-and-checkout-PostgreSQL-source-code"><a href="#3-Install-git-and-checkout-PostgreSQL-source-code" class="headerlink" title="3. Install git and checkout PostgreSQL source code"></a>3. Install git and checkout PostgreSQL source code</h4><p>PostgreSQL has the source code available on github, in order to check out the source code, you need to install git using the command below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install git -y</span><br></pre></td></tr></table></figure><p>PostgreSQL has a version 12 released in October 2019, and later was upgraded to 12.1 in November. This tutorial will use the latest PostgreSQL12 stable branch to explain how to build and debug the source code using the latest Eclipse IDE. Run the commands below to check out version 12.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">$ mkdir sandbox</span><br><span class="line">$ cd sandbox&#x2F;</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;postgres&#x2F;postgres</span><br><span class="line">$ cd postgres&#x2F;</span><br><span class="line">$ git checkout REL_12_STABLE</span><br><span class="line">$ git branch</span><br><span class="line">* REL_12_STABLE</span><br></pre></td></tr></table></figure><p>Now, we are on PostgreSQL 12 stable release branch.</p><h4 id="4-Install-PostgreSQL-build-dependency"><a href="#4-Install-PostgreSQL-build-dependency" class="headerlink" title="4. Install PostgreSQL build dependency"></a>4. Install PostgreSQL build dependency</h4><p>In order to build PostgreSQL source code, we need to install the basic build dependency with below command.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y pkg-config build-essential ibreadline-devbison flex</span><br></pre></td></tr></table></figure><p>With the command above, the basic libraries and utilities for building c and cpp code will be installed, such as, dpkg-dev, gcc, g++, make and libc6-dev. Moreover, the libraries and tools required by PostgreSQL such as libreadline, zlib, bison and flex will also be installed as well.</p><h4 id="5-Configure-PostgreSQL-and-generate-Makefiles"><a href="#5-Configure-PostgreSQL-and-generate-Makefiles" class="headerlink" title="5. Configure PostgreSQL and generate Makefiles"></a>5. Configure PostgreSQL and generate Makefiles</h4><p>Before importing PostgreSQL source code into Eclipse as a project, we need to use the configure script provided by PostgreSQL to generate the Makefiles. Run the command below to prepare the Makefiles for Eclipse later to use.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;configure --prefix&#x3D;$HOME&#x2F;eclipse-workspace&#x2F;postgres --enable-debug CFLAGS&#x3D;&#39;-O0&#39;</span><br></pre></td></tr></table></figure><p><code>--prefix</code> is used to define the installation path, in this case, all the PostgreSQl binaries, libraries, and utilities will be installed to $HOME/eclipse-workspace</p><p><code>--enable-debug</code> is used to enable gdb debugging option, so that we can use Eclipse to set up a breakpoint to trace the source code.</p><p><code>--CFLAG</code> is used to specify the compile options, <code>-O0</code> is used to remove code optimization.</p><p>If all the dependency has been installed properly, then <code>Makefile.global</code> should be generated in <code>./src</code> folder. To verify the <code>Makefile.global</code> has been created properly, using <code>vi</code> to open it and check the <code>CFLAG</code> parameter to make sure <code>-g</code> and <code>-O0</code> are set. It should look like below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS &#x3D; -Wall -Wmissing-prototypes -Wpointer-arith -Wdeclaration-after-statement -Werror&#x3D;vla -Wendif-labels -Wmissing-format-attribute -Wformat-security -fno-strict-aliasing -fwrapv -fexcess-precision&#x3D;standard -Wno-format-truncation -g -O0</span><br></pre></td></tr></table></figure><p>It is better to run the commands below to test if everything has been set up properly before import posgtres source code into Eclipse. After a while, if you see the message <em>“All of PostgreSQL successfully made. Ready to install.”</em> then we are ready to setup Eclipse IDE.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd $HOME&#x2F;sandbox&#x2F;postgres</span><br><span class="line">$ make</span><br><span class="line">… …</span><br><span class="line">All of PostgreSQL successfully made. Ready to install.</span><br></pre></td></tr></table></figure><h4 id="6-Install-Eclipse-IDE-for-C-C-Developers"><a href="#6-Install-Eclipse-IDE-for-C-C-Developers" class="headerlink" title="6. Install Eclipse IDE for C/C++ Developers"></a>6. Install Eclipse IDE for C/C++ Developers</h4><p>Now, go to the Eclipse website and download the latest <code>Eclipse IDE for C/C++ Developers</code> for Linux <code>64-bit</code>. After the download is finished, simply untar the file to a folder, for example, <code>/opt</code>. If you prefer to open the Eclipse from Desktop, then you need to run below commands to set up the <code>Desktop Shortcut</code>. </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Update Packages Index</span><br><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line"># Install GNOME Panel</span><br><span class="line">$ sudo apt-get install --no-install-recommends gnome-panel -y</span><br><span class="line"></span><br><span class="line"># Create Desktop Shortcuts</span><br><span class="line">$ gnome-desktop-item-edit ~&#x2F;Desktop&#x2F; --create-new</span><br></pre></td></tr></table></figure><p>Make sure you choose the right eclipse binary and then fill in the Name and Comment.</p><p><img src="/images/img/eclipse-desktop-shortcut.png" alt="GitHub Logo"></p><p>Eclipse requires a JRE environment to be installed, so run below command before open Eclipse.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install default-jre -y</span><br></pre></td></tr></table></figure><h4 id="7-Import-Postgres-project"><a href="#7-Import-Postgres-project" class="headerlink" title="7. Import Postgres project"></a>7. Import Postgres project</h4><p>After the JRE environment has been installed successfully, double click eclipse icon from Desktop to open the IDE. From <code>Project Explorer</code>, click on <code>Import project…</code>, then fill in the information like below screenshot and then click <code>Finish</code> button.</p><p><img src="/images/img/import-postgres-project.png" alt="GitHub Logo"></p><p>After project importing finished, right click on the project, select <code>Build Targets</code>, then <code>Create…</code>, and fill in <code>install</code> to the Target name, then click on <code>OK</code>.</p><p><img src="/images/img/create-build-target.png" alt="GitHub Logo"></p><p>To build and install PostgreSQL, right click on <code>Build Target</code>, then click <code>Build…</code>, and select <code>install</code> and click on <code>Build</code>.</p><p>It may take a while to compile all the source code and install the binaries, libraries, and utilities. Once finished, you should see a message from <code>Eclipse Console</code> <em>“PostgreSQL installation complete.”</em></p><p>Open a Linux terminal, type below commands if PostgreSQL has been installed into the folder <code>$HOME/eclipse-workspace/postgres</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd $HOME&#x2F;eclipse-workspace&#x2F;postgres</span><br><span class="line">$ ls -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 david david 4096 Dec 28 12:08 bin</span><br><span class="line">drwxrwxr-x 6 david david 4096 Dec 28 12:08 include</span><br><span class="line">drwxrwxr-x 4 david david 4096 Dec 28 12:08 lib</span><br><span class="line">drwxrwxr-x 6 david david 4096 Dec 28 12:08 share</span><br></pre></td></tr></table></figure><h4 id="8-Configure-and-start-Postgres-server"><a href="#8-Configure-and-start-Postgres-server" class="headerlink" title="8. Configure and start Postgres server"></a>8. Configure and start Postgres server</h4><p>Now, run below commands to setup the environment variables <code>PATH</code> and <code>PGDATA</code> in the Linux terminal.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH&#x3D;$HOME&#x2F;eclipse-workspace&#x2F;postgres&#x2F;bin:$PATH</span><br><span class="line">$ mkdir -p $HOME&#x2F;pg12data&#x2F;data&#x2F;</span><br><span class="line">$ export PGDATA&#x3D;$HOME&#x2F;pg12data&#x2F;data&#x2F;</span><br></pre></td></tr></table></figure><p>Here, we set up the path for looking up all PosgreSQL binaries, create a new folder for PosgreSQL database files and settings and then export it as an environment variable <code>PGDATA</code> to this terminal.</p><p>After the environment has been setup, we need to use the same terminal to initialize the database and setup a superuser password. Notes, the database initialization needs to be done only once.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ initdb -D $HOME&#x2F;pg12data&#x2F;data&#x2F; -U postgres -W</span><br><span class="line">Enter new superuser password: postgres</span><br><span class="line">Enter it againpostgres</span><br></pre></td></tr></table></figure><p>Now, it is time to bring up the postgres server from the terminal by using the command below.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ pg_ctl -D $HOME&#x2F;pg12data&#x2F;data&#x2F; -l logfile start</span><br><span class="line">waiting for server to start.... done</span><br><span class="line">server started</span><br></pre></td></tr></table></figure><p>To check if all the services has started properly, run below commands,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef |grep postgres</span><br><span class="line">david    32445     1  0 12:35 ?        00:00:00 &#x2F;home&#x2F;david&#x2F;eclipse-workspace&#x2F;postgres&#x2F;bin&#x2F;postgres -D &#x2F;home&#x2F;david&#x2F;pg12data&#x2F;data</span><br><span class="line">david    32447 32445  0 12:35 ?        00:00:00 postgres: checkpointer   </span><br><span class="line">david    32448 32445  0 12:35 ?        00:00:00 postgres: background writer   </span><br><span class="line">david    32449 32445  0 12:35 ?        00:00:00 postgres: walwriter   </span><br><span class="line">david    32450 32445  0 12:35 ?        00:00:00 postgres: autovacuum launcher   </span><br><span class="line">david    32451 32445  0 12:35 ?        00:00:00 postgres: stats collector   </span><br><span class="line">david    32452 32445  0 12:35 ?        00:00:00 postgres: logical replication launcher </span><br><span class="line">$ sudo netstat -autnlp |grep 5432</span><br><span class="line">tcp        0      0 127.0.0.1:5432          0.0.0.0:*               LISTEN      32445&#x2F;postgres</span><br></pre></td></tr></table></figure><p>From the output, we can tell a posgres server with pid <code>32445</code> is listening on port <code>5432</code>, and all the other required servers are also running, such as <code>background writer</code> which issues writes of “dirty” (new or modified) shared buffers. Without any change to the default configuration, the above shows how many servers are supposed to start after issuing a <code>pg_ctl</code> start command.</p><h4 id="9-Connect-a-client-to-Postgres-server"><a href="#9-Connect-a-client-to-Postgres-server" class="headerlink" title="9. Connect a client to Postgres server"></a>9. Connect a client to Postgres server</h4><p>To connect a <code>psql</code> client to the postgres server locally, you can run the command below in the same terminal.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ psql -U postgres</span><br><span class="line">psql (12.1)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line">postgres&#x3D;# \c</span><br><span class="line">You are now connected to database &quot;postgres&quot; as user &quot;postgres&quot;</span><br><span class="line">postgres&#x3D;#</span><br></pre></td></tr></table></figure><p>Now, if you check the postgres processes again, a new postgres server should show in the list,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef |grep postgres</span><br><span class="line">david      721  6008  0 13:02 pts&#x2F;1    00:00:00 psql -U postgres</span><br><span class="line">david      723 32445  0 13:03 ?        00:00:00 postgres: postgres postgres [local] idle</span><br></pre></td></tr></table></figure><p>Here, <code>psql</code> is the client running on the same Linux machine, and a new posgres process with pid <code>723</code> is the new server to deal with all the requests coming from the client psql with pid <code>721</code>.</p><h4 id="10-Attach-postgres-to-debug-a-simple-query"><a href="#10-Attach-postgres-to-debug-a-simple-query" class="headerlink" title="10. Attach postgres to debug a simple query"></a>10. Attach postgres to debug a simple query</h4><p>Now, we are finally ready to attach this new postgres server to trace a simple query in Eclipse.<br>Right click on project <code>pgdev</code>, select <code>Debug As</code>, then select <code>Debug Configurations…</code><br>Right click on <code>C/C++ Attach Application</code>, then fill in the posgres binary path in <code>C/C++ Application</code>.</p><p><img src="/images/img/attach-postgres.png" alt="GitHub Logo"></p><p>After all the setting is done by referring above screenshot, click <code>Apply</code>, then click <code>Debug</code>.</p><p>A Select Processes window will pop up, type <em>“postgres”</em> to show all running postgres servers, then select postgres server with pid <code>723</code> which is the one connected to the psql client. Click <code>OK</code> to launch the debugging window in Eclipse. </p><p><img src="/images/img/find-postgres-server.png" alt="GitHub Logo"></p><p>Well, you probably will end up with an error like below. This is caused by an Ubuntu built-in feature which doesn’t allow ptrace of a <code>non-child</code> process by any <code>non-root</code> users. </p><p><img src="/images/img/pid-attach-permission-issue.png" alt="GitHub Logo"></p><p>To resolve this issue, we need to temporarily disable this feature by issue a command below,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope</span><br><span class="line">1</span><br><span class="line">$ echo 0 | sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope</span><br><span class="line">[sudo] password for avid: </span><br><span class="line">0</span><br><span class="line">$ cat &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>To permanently disable this feature, edit the file <code>/etc/sysctl.d/10-ptrace.conf</code>.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;etc&#x2F;sysctl.d&#x2F;10-ptrace.conf</span><br><span class="line">kernel.yama.ptrace_scope &#x3D; 0</span><br></pre></td></tr></table></figure><p>Once the permission issue has been fixed, relaunch the debug by attaching to running postgre server with pid <code>723</code> again, then you should see below window, press <code>F8</code> to resume this postgre process.</p><p><img src="/images/img/hit-breakpoint.png" alt="GitHub Logo"></p><h4 id="11-Debug-a-simple-query"><a href="#11-Debug-a-simple-query" class="headerlink" title="11. Debug a simple query"></a>11. Debug a simple query</h4><p>Now, back to the <code>psql</code> client terminal, create a table and insert a few records, and then perform a simple query on this table.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres&#x3D;# CREATE TABLE test (id serial PRIMARY KEY, name VARCHAR(20));</span><br><span class="line">CREATE TABLE</span><br><span class="line">postgres&#x3D;# INSERT INTO test VALUES(1, &#39;test1&#39;);</span><br><span class="line">INSERT 0 1</span><br><span class="line">postgres&#x3D;# INSERT INTO test VALUES(2, &#39;test2&#39;);</span><br><span class="line">INSERT 0 1</span><br><span class="line">postgres&#x3D;# SELECT id, name FROM test;</span><br><span class="line"> id | name  </span><br><span class="line">----+-------</span><br><span class="line">  1 | test1</span><br><span class="line">  2 | test2</span><br><span class="line">(2 rows)</span><br></pre></td></tr></table></figure><p>If everything works fine, then, switch back to Eclipse, to set up a <code>breakpoint</code> by entering <code>b exec_simple_query</code> in <code>Debugger Console</code>.</p><p><img src="/images/img/debugger-console.png" alt="GitHub Logo"></p><p>or using the search function in Eclipse to find out <code>exec_simple_query</code> function definition, i.e. line <code>985</code> in <code>./sandbox/postgres/src/backend/tcop/postgres.c</code>, and right click on the left side bar and select <code>Toggle Breakpoint</code>, then one tiny dot will be showing up to indicate the breakpoint is on.</p><p><img src="/images/img/eclipse-simple-query.png" alt="GitHub Logo"></p><p>Then, click on Resume button or press <code>F8</code>, or enter <code>c</code> in the <code>Debugger Console</code> to continue postgre process. When this postgres server is running again, then switch back to the <code>psql</code> client terminal and repeat the previous SELECT query command.</p><p>At this time, you should see the <code>psql</code> client is hanging without any results returned.<br>Now, switch back to Eclipse. You should also see this postgres process stopped in <code>exec_simple_query</code> function. If you enter <code>bt</code> in <code>Debugger Console</code>, then you should be able to see the backtrace below highlighted.</p><p><img src="/images/img/debugger-console-bt.png" alt="GitHub Logo"></p><p>To check any function and value in the backtrace, for example, frame 5 PostmasterMain, type <code>f 5</code> in <code>Debugger Console</code> and then <code>Enter</code>. Eclipse will navigate you to the function immediately and highlight it. From there you can use <code>Ctrl + left click</code> to jump into the function definition and check the details. </p><p>Image-11<br><img src="/images/img/eclipse-frame-5.png" alt="GitHub Logo"></p><p>After finishing all the check, then resume the postgres process, and then switch to the <code>psql</code> client terminal, you should see the results is returned.</p><p><em>Enjoy your debugging with Eclipse for PostgreSQL.</em></p><p><em><strong>Reference:</strong></em> </p><p><a href="https://www.highgo.ca/2019/10/08/newbie-to-postgresql-where-to-start" target="_blank" rel="noopener">1. Newbie to PostgreSQL – where to start</a> </p><p><a href="https://www.highgo.ca/2019/10/03/trace-query-processing-internals-with-debugger" target="_blank" rel="noopener">2. Trace Query Processing Internals with Debugger</a> </p><p><a href="https://wiki.postgresql.org/wiki/Working_with_Eclipse" target="_blank" rel="noopener">3. Working with Eclipse</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;1-Overview&quot;&gt;&lt;a href=&quot;#1-Overview&quot; class=&quot;headerlink&quot; title=&quot;1. Overview&quot;&gt;&lt;/a&gt;1. Overview&lt;/h4&gt;&lt;p&gt;This tutorial provides detailed inst
      
    
    </summary>
    
    
      <category term="PostgreSQL" scheme="https://idrawone.github.io/categories/PostgreSQL/"/>
    
      <category term="Eclipse" scheme="https://idrawone.github.io/categories/PostgreSQL/Eclipse/"/>
    
      <category term="Debug" scheme="https://idrawone.github.io/categories/PostgreSQL/Eclipse/Debug/"/>
    
    
  </entry>
  
</feed>
